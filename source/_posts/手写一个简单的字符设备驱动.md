---
title: 手写一个简单的字符设备驱动
date: 2016-06-10 09:52:10
tags: [Embedded, Device Driver, C]
---

　　在嵌入式Linux中，操作GPIO并不是一件难事，我们可以通过虚拟文件系统或者其他相关库轻易地控制一个引脚的电平。不过当我们需要利用GPIO来控制一个设备时，一切就不再是那么简单了，因为控制引脚电平是一种非常`low-level`的原始操作，而控制设备行为是一种`high-level`的语义操作，这之间的巨大鸿沟显示不是普通用户所能填平的，此时就需要程序员出马了。在计算机领域有这么一句话：`计算机学科的所有问题都能通过增加一层额外的抽象层来解决`，上述问题也不例外，我们可以在用户与设备之间建立一个抽象层，它向用户提供浅显易懂的语义操作，而对下层设备的控制仍是通过GPIO原始操作来完成，这对用户而言是透明的，所以他们不会再因繁琐的GPIO操作而烦恼，上述问题也即得到了解决。
<!--more-->
　　这里提到的抽象层正是本文将要实现的字符设备驱动程序。

    设备：
    - Rraspberry Pi I
    - MAX7219驱动的8x8 LED矩阵

> Start from here

## 预备知识
　　在编写设备驱动程序之前，我们需要先把底层GPIO操作打通。这里我们通过sysfs目录中的特殊文件来控制GPIO引脚。
　　进入`/sys/class/gpio/`目录，我们需要关注该目录下的两个文件，分别为`export`和`unexport`，向`export`文件中写入引脚编号表示启用该引脚，向`unexport`文件中写入引脚编号表示停用该引脚。如下所示：
``` bash
pi@raspberrypi /sys/class/gpio $ l
total 0
-rwxrwx--- 1 root gpio 4096 Jun  4 11:17 export
lrwxrwxrwx 1 root gpio    0 Jun  4 11:17 gpiochip0 -> ../../devices/soc/20200000.gpio/gpio/gpiochip0
-rwxrwx--- 1 root gpio 4096 Jun  4 13:05 unexport
pi@raspberrypi /sys/class/gpio $ echo 8 > export
pi@raspberrypi /sys/class/gpio $ echo 10 > export
pi@raspberrypi /sys/class/gpio $ l
total 0
-rwxrwx--- 1 root gpio 4096 Jun  4 13:05 export
lrwxrwxrwx 1 root gpio    0 Jun  4 13:05 gpio10 -> ../../devices/soc/20200000.gpio/gpio/gpio10
lrwxrwxrwx 1 root gpio    0 Jun  4 13:05 gpio8 -> ../../devices/soc/20200000.gpio/gpio/gpio8
lrwxrwxrwx 1 root gpio    0 Jun  4 11:17 gpiochip0 -> ../../devices/soc/20200000.gpio/gpio/gpiochip0
-rwxrwx--- 1 root gpio 4096 Jun  4 13:05 unexport
pi@raspberrypi /sys/class/gpio $
```
　　注意到，当我们启用GPIO8和GPIO10两个引脚时，目录下出现了两个链接文件，分别链接到两个引脚的控制目录，我们可以`cd`进入控制目录，对引脚进行控制：
``` bash
pi@raspberrypi /sys/class/gpio $ cd gpio8
pi@raspberrypi /sys/class/gpio/gpio8 $ l
total 0
-rw-r--r-- 1 root root 4096 Jun  4 13:07 active_low
lrwxrwxrwx 1 root root    0 Jun  4 13:07 device -> ../../../20200000.gpio
-rw-r--r-- 1 root root 4096 Jun  4 13:07 direction
-rw-r--r-- 1 root root 4096 Jun  4 13:07 edge
drwxr-xr-x 2 root root    0 Jun  4 13:07 power
lrwxrwxrwx 1 root root    0 Jun  4 13:05 subsystem -> ../../../../../class/gpio
-rw-r--r-- 1 root root 4096 Jun  4 13:05 uevent
-rw-r--r-- 1 root root 4096 Jun  4 13:07 value
pi@raspberrypi /sys/class/gpio/gpio8 $
```
　　其中`direction`文件表示引脚的模式，可以通过写入`in`或`out`来将引脚改为输入模式或输出模式，`value`文件表示引脚当前值，在输出模式下，我们可以通过写入`0`或`1`来控制引脚电平。
　　以上即是操作GPIO所需要的全部预备知识，下面我们来了解一下如何驱动MAX7219芯片。
![Selection_119.png-42.3kB][1]
　　上图为MAX7219的引脚图，可以看到，主控板只需要控制三个引脚，分别为CLK、LOAD/CS以及DIN，其中CLK为时钟信号，DIN为数据串行输入，LOAD/CS为数据载入信号，它们的时序图如下所示：
![Selection_120.png-34.7kB][2]
　　根据这张时序图，我们可以总结出以下几点信息：
1. MAX7219一次载入16位数据；
2. 当LOAD/CS信号拉低时，芯片开始载入数据，当LOAD/CS信号拉高时，数据载入完成；
3. DIN上的每一位数据在CLK的上升沿被锁存；
4. 数据从最高位到最低位依次被锁存。

　　其中16位数据格式如下所示，注意第8位到第11位表示寄存器地址，第0位到第7位表示送入该寄存器的数值：
![Selection_121.png-6.9kB][3]
　　知道这些信息还不够，因为我们还不知道到底要送入什么数据。下面就对MAX7219芯片的内部寄存器以及各自的作用做简单介绍。
![Selection_122.png-75.1kB][4]
　　忽略0号寄存器，因为它不干任何事。1号寄存器到8号寄存器，即Digit 0到Digit 7，用于控制LED点阵的显示，具体来说，几号寄存器就控制第几列的LED，而寄存器内存放的8位数值就决定了该列LED的显示状态，举个例子，假设5号寄存器存放着0x41，那么对应到8x8 LED点阵中就以为着第5列中，第1、7行的LED被点亮，其余行的LED全部熄灭。Decode Mode寄存器用于控制数据的译码方式，我们这里不采用译码，所以将该寄存器置0即可。Intensity寄存器表示LED点阵的亮度，实践证明，为了保护眼睛，还是将这个寄存器的值调至0或1吧，否则非常刺眼。Scan Limit寄存器可以理解为有几行LED被使用，0表示只使用1行，7表示使用全部8行，所以我们将该寄存器置为7，因为我们需要使用8x8 LED点阵中的所有灯。Shutdown寄存器只有两种值，0或1，我们将其置为1，表示正常操作模式。最后的Display Test寄存器非常关键，它也只有两个值，0或1，0表示正常操作模式，而1表示显示测试模式，在显示测试模式下，所有LED都被点亮，只有将该寄存器置为0，我们才能正常控制LED的亮灭。
　　以上即为驱动MAX7219的所有预备知识，下面我们开始编写程序来驱动MAX7219芯片，从而控制8x8 LED点阵的图形字符显示。

## 通过GPIO控制LED点阵

　　首先，我们实现一个数据载入函数。
``` c
// writeData() & writeByte()
void writeByte(unsigned char c);
void writeData(unsigned char addr, unsigned char data) {
    write(pinCS, "0", 1);
    writeByte(addr);
    writeByte(data); // 先送地址，再送数据
    write(pinCS, "1", 1);
}
void writeByte(unsigned char c) {
    int i;
    for (i = 0; i < 8; i++) {
        write(pinCLK, "0", 1);
        if (c & 0x80) // 先送最高位
            write(pinDIN, "1", 1);
        else
            write(pinDIN, "0", 1);
        write(pinCLK, "1", 1); // 时钟上升沿锁存数据
        c <<= 1; // 循环左移
    }
}
```
　　结合MAX7219芯片的驱动方式，上述两个函数应该比较容易理解。实现了上述数据载入函数后，我们对MAX7219芯片的控制就变得非常容易了，直接调用`writeData`函数向寄存器中写数据即可。
``` c
// main()
int main() {
    pinCS = open("/sys/class/gpio/gpio8/value", O_RDWR);
    pinDIN = open("/sys/class/gpio/gpio10/value", O_RDWR);
    pinCLK = open("/sys/class/gpio/gpio11/value", O_RDWR);

    pinCS_MODE = open("/sys/class/gpio/gpio8/direction", O_RDWR); # GPIO8对应CS引脚
    pinDIN_MODE = open("/sys/class/gpio/gpio10/direction", O_RDWR); # GPIO10对应DIN引脚
    pinCLK_MODE = open("/sys/class/gpio/gpio11/direction", O_RDWR); # GPIO11对应CLK引脚
    write(pinCS_MODE, "out", 3);
    write(pinDIN_MODE, "out", 3);
    write(pinCLK_MODE, "out", 3); // 改为输出模式

    // 设置控制寄存器，参见预备知识
    writeData(0x09, 0x00);
    writeData(0x0a, 0x00);
    writeData(0x0b, 0x07);
    writeData(0x0c, 0x01);
    writeData(0x0f, 0x00);

    while (1) { // 输出一个'桃心'
        writeData(0x01, 0x00);
        writeData(0x02, 0x6c);
        writeData(0x03, 0x92);
        writeData(0x04, 0x82);
        writeData(0x05, 0x44);
        writeData(0x06, 0x28);
        writeData(0x07, 0x10);
        writeData(0x08, 0x00);
    }
```

　　为了看到上述代码的运行效果，首先将MAX7219的VCC引脚连接到5V正极，GND引脚接地，CLK引脚接到树莓派板卡的GPIO11，DIN接到GPIO10，LOAD/CS引脚接到GPIO8，再利用export启用GPIO8、GPIO10、GPIO11三个引脚。编译上述代码，然后以`root`权限运行程序(只有root能读写direction、value文件)，当然，也可以通过`chmod`命令修改direction、value文件的权限，再以普通用户的身份运行程序。LED点阵显示效果如下所示：

![IMG_20160604_220535.jpg-131.6kB][5]

## 设计字符设备驱动程序

　　通过前面的实验，我们应该能够熟练操作GPIO来控制LED点阵的显示了，现在我们开始为设备编写驱动程序，为用户提供更为抽象的控制接口。我们的目标是，用户能够通过write函数写入一串字符串，然后LED点阵将该字符串以每个字符停留500ms的速度依此显示。
　　在编写代码之前，我们需要了解一些设备驱动程序的基本知识。我们知道Linux对设备的操作是通过调用驱动程序来实现的，但驱动程序那么多，Linux怎么知道设备对应的驱动是哪个？其实，设备与驱动之间的map关系是通过一个`Major number`和`Minor number`来实现的，我们可以通过`ls -l /dev`查看设备的`Major number`和`Minor number`：
``` bash
pi@raspberrypi ~/Documents/Driver $ ls -l /dev/mmcblk0*
brw-rw---T 1 root floppy 179, 0 Jun  4 11:17 /dev/mmcblk0 # 179为Major number 0为Minor number
brw-rw---T 1 root floppy 179, 1 Jun  4 11:17 /dev/mmcblk0p1
brw-rw---T 1 root floppy 179, 2 Jun  4 11:17 /dev/mmcblk0p2
```
`Major number`用于区分不同类型的设备，而`Minor number`用于区分同一类型的不同设备，所以`Major number`才是真正将设备和驱动map到一起的关键数。
那我们怎么才能为设备驱动程序注册一个`Major number`呢？这里就要引入两个函数：
``` c
// 为字符设备驱动程序注册Major number
int register_chrdev(unsigned int major,const char *name,struct file_operations *fops);
// 取消之前的注册
void unregister_chrdev(unsigned int major, const char *name);
```
　　我们可以通过`register_chrdev`这个函数来为字符设备驱动程序注册一个`Major number`，这个函数调用需要三个参数，分别为我们指定的`Major number`、设备名字以及文件操作结构，前面两个参数好理解，最后的文件操作结构又是啥呢？ 其实，`file_operations`这个结构就是用来指明操作设备会调用哪些函数，具体如下所示：
``` c
static struct file_operations fops = {
    .read = dev_read, // 读取设备时调用dev_read函数
    .open = dev_open, // 打开设备时调用dev_open函数
    .write = dev_write, // 写设备时调用dev_write函数
    .release = dev_rls // 关闭设备时调用dev_rls函数
};
```

　　此时，相信你已经对字符设备驱动程序的框架有一定的理解了，这里简单总结一下，我们需要为几个常见的文件操作，比如打开、读写以及关闭，设计对应的操作函数，使用结构`file_operations`存放这些函数地址，然后利用`register_chrdev`函数为驱动注册一个`Major number`，这个数不能与现有的驱动冲突(可以通过`cat /proc/devices`查看当前所有设备驱动的`Major number`)！之后我们利用`mknod`命令创建一个`Major number`相同的设备文件，当我们操作该设备文件时，Linux就会找到我们的驱动程序，并根据`file_operations`结构找到相应的处理函数，执行该函数来完成这次操作。明白了这些原理，接下来就是真正地代码实现了。
　　首先我们会遇到一个问题，`register_chrdev`和`unregister_chrdev`函数只能在内核态调用，用户态下是不可能注册驱动程序的，此时我们该怎么处理呢？有没有办法让自己的程序进入内核态运行？答案是肯定的，我们可以使用装载内核模块来实现对设备驱动程序的注册(这里我假设你已经对内核模块有一定的了解，甚至有过一些实践，如果你没有接触过内核模块，建议搜索相关资料先了解一下)，代码框架如下所示：
``` c
static struct file_operations fops = {
    .read = dev_read,
    .open = dev_open,
    .write = dev_write,
    .release = dev_rls
};
static int dev_open(struct inode *i, struct file *f);
static ssize_t dev_read(struct file *f, char *buf, size_t len, loff_t *off);
static ssize_t dev_write(struct file *f, const char *buf, size_t len, loff_t *off);
static int dev_rls(struct inode *i, struct file *f);

int init_module(void) { // 装载模块时会执行这个函数
    int t = register_chrdev(218, "ledDev", &fops); // 为驱动注册Major number为218
    if (t < 0)
        printk(KERN_ALERT "Device registration failed.\n");
    else
        printk(KERN_ALERT "Device registered.\n");
    return 0;
}

void cleanup_module(void) { // 卸载模块时会执行这个函数
    unregister_chrdev(218, "ledDev");
    printk(KERN_ALERT "Device unregistered.\n");
}
```
　　有了这个框架，想必你已经有一些具体的实现思路了。对于我们的LED点阵设备，我们不需要读，只需要实现写操作，而写操作在之前的GPIO控制部分中已经有所涉及，看来我们离最终的目标已经不远了。不过，还有一个严峻的问题摆在我们面前，我们之前实现的控制LED点阵显示字符涉及到了大量文件I/O，然而Linux在内核态是无法使用libc的，而且Linux Kernel开发者一再说明，永远不要在内核代码中读写文件，因为这可能会给系统带来无穷的麻烦(如果你想了解更多，请参阅[这篇文档](http://www.linuxjournal.com/article/8110?page=0,0))，事实确实如此，因为我最初版本的驱动程序就直接导致了系统崩溃，后来调试过程中也多次造成了`segment overflow`错误。然而，本次实验对LED点阵的控制必须要通过操纵value文件来实现，我们也只好强撸一把了。这里直接贴出我设计的文件I/O函数：
``` c
struct file *openFile(const char *path) {
    struct file *fil = NULL;
    mm_segment_t old_fs;
    printk(KERN_ALERT ">>> openFile triggered.\n");

    old_fs = get_fs();
    set_fs(get_ds());
    fil = filp_open(path, O_RDWR, 0664);
    set_fs(old_fs);

    return fil;
}
static int writeFile(struct file *fil, const char *buf, size_t len) {
    mm_segment_t old_fs;
    loff_t off = 0;
    int ret;

    //printk(KERN_ALERT ">>> writeFile triggered.\n");
    old_fs = get_fs();
    set_fs(get_ds());
    ret = vfs_write(fil, buf, len, &off);
    set_fs(old_fs);

    return ret;
}
static void closeFile(struct file *fil) {
    printk(KERN_ALERT ">>> closeFile triggered.\n");
    filp_close(fil, NULL);
}
```
　　注意到，我们使用到了`set_fs()`来解决地址空间的不对应问题，这里我其实也没理解透，所以不敢多做解释，有兴趣的同学可以参阅[这篇文档](http://www.linuxjournal.com/article/8110?page=0,1)。
　　如上，我们实现了在内核态对文件进行读写操作的封装函数，现在可以正式写LED点阵的控制代码了！首先是打开设备文件时的操作：
``` c
// open device
static int dev_open(struct inode *i, struct file *f) {
    printk(KERN_ALERT "### dev_open.\n");
    exportPin(); // 启用8、10、11引脚
    setDirection(); // 设置为输出模式
    openPin(); // 打开value文件
    pinInit(); // 初始化，设置控制寄存器

    times++;
    printk(KERN_ALERT "Device opened %d times\n", times);
    return 0;
}
static void exportPin(void) {
    struct file *f;
    printk(KERN_ALERT "Start export pin.\n");
    f = openFile("/sys/class/gpio/export");
    if (f == NULL) {
        printk(KERN_ALERT "Cannot open /sys/class/gpio/export\n");
        return;
    }
    writeFile(f, "8", 1);
    writeFile(f, "10", 2);
    writeFile(f, "11", 2);
    closeFile(f);
}
static void setDirection(void) {
    struct file *f;

    printk(KERN_ALERT "Start set direction.\n");
    f = openFile("/sys/class/gpio/gpio8/direction");
    if (f == NULL) {
        printk(KERN_ALERT "Cannot open /sys/class/gpio/gpio8/direction.\n");
        return;
    }
    writeFile(f, "out", 3);
    closeFile(f);
    // 这里省去对gpio10、gpio11的设置，因为和gpio8设置完全一样
}
static void openPin(void) {
    printk(KERN_ALERT "Start open pin.\n");
    pinCS = openFile("/sys/class/gpio/gpio8/value");
    pinDIN = openFile("/sys/class/gpio/gpio10/value");
    pinCLK = openFile("/sys/class/gpio/gpio11/value");
}
static void pinInit(void) {
    printk(KERN_ALERT "Start init pin.\n");
    __writeData(0x09, 0x00);
    __writeData(0x0a, 0x00);
    __writeData(0x0b, 0x07);
    __writeData(0x0c, 0x01);
    __writeData(0x0f, 0x00);
}
```
这部分和之前通过GPIO操作LED点阵的步骤基本一致，应该不难理解。最后还剩一个关键的工作——写设备，即向设备写入字符串，然后控制LED点阵依次显示各个字符，每个字符停留500ms：
``` c
static ssize_t dev_write(struct file *f, const char *buf, size_t len, loff_t *off) {
    printk(KERN_ALERT "### dev_write.\n");
    writeString(buf, len);
    return 1;
}
static void writeString(const char *str, size_t len) {
    int i;
    for (i = 0; i < len; i++) {
        writeChar(0xFF);
        set_current_state(TASK_INTERRUPTIBLE); // 设置为可中断切换
        schedule_timeout(0.05*HZ); // 50ms
        writeChar(str[i]);
        set_current_state(TASK_INTERRUPTIBLE);
        schedule_timeout(0.5*HZ); // 500ms
    }
}
static void writeChar(char c) {
    int i;
    for (i = 0; i < 8; i++) {
        // 采用CP437字体，这里不贴出字体映射表，直接提供下载
        __writeData(i+1, font[(unsigned int)c][i]); // 这里的__writeData等同于前面设计的writeData
    }
}
static void __writeData(unsigned char addr, unsigned char b) {
    writeFile(pinCS, "0", 1);
    __writeByte(addr);
    __writeByte(b);
    writeFile(pinCS, "1", 1);
}
static void __writeByte(unsigned char b) {
    int i;
    for (i = 0; i < 8; i++) {
        writeFile(pinCLK, "0", 1);
        if (b & 0x80)
            writeFile(pinDIN, "1", 1);
        else
            writeFile(pinDIN, "0", 1);
        writeFile(pinCLK, "1", 1);
        b <<= 1;
    }
}
```
　　注意到，我们在输出字符串时，为每个字符分配了500ms的停留时长，这里用到了`schedule_timeout`这个函数，它配合前面的`set_current_state(TASK_INTERRUPTIBLE)`可以实现500ms的延时，同时，在这段延时过程中，进程可以被中断，防止write函数独占CPU。([点击这里](http://xiaoan.org/share/font.c)下载字体映射表，将font变量移植到驱动程序代码中)
　　最后贴出Makefile文件：
``` makefile
# 代码文件名为leddev.c
obj-m += leddev.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```
　　编译完成后，装载内核模块，然后直接使用libc函数`open`、`write`对设备文件进行读写测试，这里我输出了`Hello, World!`字符串，如下所示(若无法观看动态图，请点击[链接](http://static.zybuluo.com/hac/leqf0qcqa7ye7eep86j6yw1p/VID2.gif))：
![VID2.gif-4751.5kB][6]

　　之前的设计中，我们将字符串分解成多个字符，其中每个字符停留500ms，依次显示，这样能够较为明显地表现出一个字符串。然而，我认为这种停顿输出的表现形式仍不够直观，滚动输出才最适合字符串，查阅资料可以发现，网上其他人对于LED点阵的实现也大多都是基于滚动输出的，因为这样的呈现效果更为直接、美观。下面，我们就对前面的设计进行简单修改，使其能够支持字符串的滚动输出。
　　如果你对我的驱动程序框架比较熟悉，那么你会发现，我们仅需要对`writeChar`和`writeString`两个函数进行简单修改，即可替换字符串输出模式。这里直接贴代码：
``` c
static void writeChar(char c, int start, int offset) {
    for (; offset < 8 && start < 8;) {
        __writeData(++offset, font[(unsigned int)c][start++]);
    }
}
static void writeString(const char *str, size_t len) {
    int i = 0, j = 0;
    while (i < len + 1) {
        if (i == 0) {
            writeChar(0xFF, j, 0); // 先输出空白字符
            writeChar(str[0], 0, 8-j); // 逐步滚入第一个字符
        }
        else if (i < len) {
            writeChar(str[i-1], j, 0); // 前一个字符持续左移，改变的是字体起始列号
            writeChar(str[i], 0, 8-j); // 后一个字符跟进，改变的是LED点阵偏移列号
        }
        else if (i == len) {
            writeChar(str[i-1], j, 0); // 最后一个字符滚出
            writeChar(0xFF, 0, 8-j); // 补上空白字符
        }
        j++;
        if (j == 9) {
            i++;
            j = 1;
        }
        set_current_state(TASK_INTERRUPTIBLE);
        schedule_timeout(0.1*HZ); // 每过0.1秒更新一次
    }
}
```
　　修改后的两个函数逻辑变得更加复杂了，可能有些难以理解，我简单解释一下。首先是`writeChar`函数，此时它会接收三个参数，分别是显示字符、起始位置、偏移位置。我们知道，字体和LED点阵其实都是8x8的矩阵，这里的起始位置`start`表示的就是显示字符字体的起始列号，而偏移位置表示的是LED点阵的偏移列号。用实际例子来解释更为直观：对于传入参数`c = 'a', start = 3, offset = 4`，此时`writeChar`函数的行为就是从LED点阵的第`5`(offset+1)列输出字符`'a'`对应字体的第`3`(start)列，同理LED点阵第`6`列输出字体的第`4`列，以此类推，直到LED点阵列号超过8或者字体列号超过7时才停止输出，而对于LED点阵前面四列，我们这里不做处理。可能有人不理解为什么offset对应的是`++offset`，而start对应的是`start++`，这里解释一下：LED点阵列号是从1开始计数，字体列号从0开始计数，而我们希望它们对外全部表现为从0开始计数，所以传入的offset需要先加1才能作为真正的LED点阵列号。
　　有了`writeChar`的实现，我们写`writeString`就简单多了，仅仅需要处理好两个字符的同时显示。我的设计目标是，先输出空白字符`0xFF`，然后字符串的各个字符依次滚动进入，直到最后一个字符全部离开LED点阵才停止输出。总共实现分为三步，代码上有简单的注释，我觉得这里很难讲清所有细节，比如为什么`j == 9`时才会让它复位为`1`，为什么不复位为`0`，为什么点阵偏移列号是`8-j`而不是其他数... ...如果你真的想理解这些细节问题，建议用笔在纸上模拟一下字符的滚动，然后理解一下`writeChar`函数，相信你能很快将`writeString`滚动输出的设计细节弄清楚。
　　最后，贴上字符串滚动输出的显示效果(若无法观看动态图，请点击[链接](http://static.zybuluo.com/hac/b7e3erklgu3j81ct8tl8gogj/VID1.gif))：
　　![VID1.gif-8631.7kB][7]

## Reference

1. [课程提供的资料](http://xianan.org/share/MAX7219.zip)(包含中英文版的datasheet以及参考代码)
2. [Writing a Linux character Device Driver](https://appusajeev.wordpress.com/2011/06/18/writing-a-linux-character-device-driver/)
3. [The Linux Kernel Module Programming Guide](http://www.tldp.org/LDP/lkmpg/2.4/html/x579.html)
4. [Max7219 Wheel in Python](https://github.com/rm-hull/max7219)
5. [Linux Device Drivers, 2nd Edition](http://www.xml.com/ldd/chapter/book/ch06.html)
6. [Driving Me Nuts - Things You Never Should Do in the Kernel](http://www.linuxjournal.com/article/8110?page=0,0)
7. [How to read/write files within a Linux kernel module](http://stackoverflow.com/questions/1184274/how-to-read-write-files-within-a-linux-kernel-module)


  [1]: http://static.zybuluo.com/hac/1gfykd2bttaxsx8fnrcfoo6l/Selection_119.png
  [2]: http://static.zybuluo.com/hac/yurvfwi9mh7opnonh7nz5xgx/Selection_120.png
  [3]: http://static.zybuluo.com/hac/xj3azhhls81m6faag21tgnrw/Selection_121.png
  [4]: http://static.zybuluo.com/hac/yqtyupvirhre9xk37u72d6te/Selection_122.png
  [5]: http://static.zybuluo.com/hac/jubd5ilx8qe145f97gau1fw2/IMG_20160604_220535.jpg
  [6]: http://static.zybuluo.com/hac/leqf0qcqa7ye7eep86j6yw1p/VID2.gif
  [7]: http://static.zybuluo.com/hac/b7e3erklgu3j81ct8tl8gogj/VID1.gif

